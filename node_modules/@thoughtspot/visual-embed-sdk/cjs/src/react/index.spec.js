"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const react_1 = tslib_1.__importDefault(require("react"));
require("@testing-library/jest-dom");
require("@testing-library/jest-dom/extend-expect");
const react_2 = require("@testing-library/react");
const types_1 = require("../types");
const test_utils_1 = require("../test/test-utils");
const index_1 = require("./index");
const allExports = tslib_1.__importStar(require("./index"));
const index_2 = require("../index");
const package_json_1 = require("../../package.json");
const auth = tslib_1.__importStar(require("../auth"));
const sessionService = tslib_1.__importStar(require("../utils/sessionInfoService"));
const thoughtSpotHost = 'localhost';
beforeAll(() => {
    (0, index_2.init)({
        thoughtSpotHost,
        authType: index_2.AuthType.None,
    });
    jest.spyOn(auth, 'postLoginService').mockImplementation(() => Promise.resolve(undefined));
    jest.spyOn(sessionService, 'getSessionInfo').mockReturnValue({
        userGUID: 'abcd',
    });
    jest.spyOn(window, 'alert');
});
describe('React Components', () => {
    describe('SearchEmbed', () => {
        it('Should Render the Iframe with props', async () => {
            const { container } = (0, react_2.render)(react_1.default.createElement(index_1.SearchEmbed, { hideDataSources: true, className: "embedClass" }));
            await (0, react_2.waitFor)(() => (0, test_utils_1.getIFrameEl)(container));
            expect((0, test_utils_1.getIFrameEl)(container).parentElement.classList.contains('embedClass')).toBe(true);
            expect((0, test_utils_1.getIFrameSrc)(container)).toBe(`http://${thoughtSpotHost}/?embedApp=true&hostAppUrl=local-host&viewPortHeight=768&viewPortWidth=1024&sdkVersion=${package_json_1.version}&authType=None&blockNonEmbedFullAppAccess=true&hideAction=[%22${types_1.Action.ReportError}%22,%22editACopy%22,%22saveAsView%22,%22updateTSL%22,%22editTSL%22,%22onDeleteAnswer%22]&preAuthCache=true&overrideConsoleLogs=true&clientLogLevel=ERROR&enableDataPanelV2=true&dataSourceMode=hide&useLastSelectedSources=false&isSearchEmbed=true&collapseSearchBarInitially=true&enableCustomColumnGroups=false&dataPanelCustomGroupsAccordionInitialState=EXPAND_ALL#/embed/answer`);
        });
        it('Should attach event listeners', async () => {
            const userGUID = 'absfdfgd';
            const { container } = (0, react_2.render)(react_1.default.createElement(index_1.SearchEmbed, { onInit: (e) => {
                    expect(e.data).toHaveProperty('timestamp');
                }, onAuthInit: (e) => {
                    expect(e.data.userGUID).toEqual(userGUID);
                } }));
            await (0, react_2.waitFor)(() => (0, test_utils_1.getIFrameEl)(container));
            const iframe = (0, test_utils_1.getIFrameEl)(container);
            (0, test_utils_1.postMessageToParent)(iframe.contentWindow, {
                type: types_1.EmbedEvent.AuthInit,
                data: {
                    userGUID,
                },
            });
        });
    });
    describe('AppEmbed', () => {
        //
    });
    describe('LiveboardEmbed', () => {
        //
        it('Should be able to trigger events on the embed using refs', async () => {
            (0, test_utils_1.mockMessageChannel)();
            const TestComponent = () => {
                const embedRef = (0, index_1.useEmbedRef)();
                const onLiveboardRendered = () => {
                    embedRef.current.trigger(types_1.HostEvent.SetVisibleVizs, ['viz1', 'viz2']);
                };
                return (react_1.default.createElement(index_1.LiveboardEmbed, { ref: embedRef, liveboardId: "abcd", onLiveboardRendered: onLiveboardRendered }));
            };
            const { container } = (0, react_2.render)(react_1.default.createElement(TestComponent, null));
            await (0, react_2.waitFor)(() => (0, test_utils_1.getIFrameEl)(container));
            const iframe = (0, test_utils_1.getIFrameEl)(container);
            jest.spyOn(iframe.contentWindow, 'postMessage');
            (0, test_utils_1.postMessageToParent)(iframe.contentWindow, {
                type: types_1.EmbedEvent.LiveboardRendered,
                data: {
                    userGUID: 'abcd',
                },
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(iframe.contentWindow.postMessage).toHaveBeenCalledWith({
                    type: types_1.HostEvent.SetVisibleVizs,
                    data: ['viz1', 'viz2'],
                }, `http://${thoughtSpotHost}`, expect.anything());
            });
        });
        it('Should render liveboard with runtime filters', async () => {
            const { container } = (0, react_2.render)(react_1.default.createElement(index_1.LiveboardEmbed, { liveboardId: "abcd", runtimeFilters: [
                    {
                        columnName: 'revenue',
                        operator: types_1.RuntimeFilterOp.EQ,
                        values: [100],
                    },
                ], excludeRuntimeFiltersfromURL: false }));
            await (0, react_2.waitFor)(() => (0, test_utils_1.getIFrameEl)(container));
            expect((0, test_utils_1.getIFrameSrc)(container)).toContain('col1=revenue&op1=EQ&val1=100');
        });
        it('Should have the correct container element', async () => {
            const { container } = (0, react_2.render)(react_1.default.createElement(index_1.LiveboardEmbed, { liveboardId: "abcd", className: "def" }));
            await (0, react_2.waitFor)(() => (0, test_utils_1.getIFrameEl)(container));
            expect(container.querySelector('div')).not.toBe(null);
            expect(container.querySelector('div').classList.contains('def')).toBe(true);
            const { container: containerSibling } = (0, react_2.render)(react_1.default.createElement(index_1.LiveboardEmbed, { liveboardId: "abcd", className: "def", insertAsSibling: true }));
            await (0, react_2.waitFor)(() => (0, test_utils_1.getIFrameEl)(containerSibling));
            expect(containerSibling.querySelector('span')).not.toBe(null);
            expect(containerSibling.querySelector('span').style.position).toBe('absolute');
            expect((0, test_utils_1.getIFrameEl)(containerSibling).classList.contains('def')).toBe(true);
            expect(containerSibling.querySelector('div')).toBe(null);
        });
        it('Should have the correct container element', async () => {
            const { container } = (0, react_2.render)(react_1.default.createElement(index_1.LiveboardEmbed, { liveboardId: "abcd", className: "def" }));
            await (0, react_2.waitFor)(() => (0, test_utils_1.getIFrameEl)(container));
            expect(container.querySelector('div')).not.toBe(null);
            expect(container.querySelector('div').classList.contains('def')).toBe(true);
            const { container: containerSibling } = (0, react_2.render)(react_1.default.createElement(index_1.LiveboardEmbed, { liveboardId: "abcd", className: "def", insertAsSibling: true }));
            await (0, react_2.waitFor)(() => (0, test_utils_1.getIFrameEl)(containerSibling));
            expect(containerSibling.querySelector('span')).not.toBe(null);
            expect(containerSibling.querySelector('span').style.position).toBe('absolute');
            expect((0, test_utils_1.getIFrameEl)(containerSibling).classList.contains('def')).toBe(true);
            expect(containerSibling.querySelector('div')).toBe(null);
        });
    });
    describe('SearchBarEmbed', () => {
        it('Should Render the Iframe with props', async () => {
            const { container } = (0, react_2.render)(react_1.default.createElement(index_1.SearchBarEmbed, { className: "embedClass", dataSource: 'test', searchOptions: {
                    searchTokenString: '[revenue]',
                    executeSearch: true,
                } }));
            await (0, react_2.waitFor)(() => (0, test_utils_1.getIFrameEl)(container));
            expect((0, test_utils_1.getIFrameEl)(container).parentElement.classList.contains('embedClass')).toBe(true);
            expect((0, test_utils_1.getIFrameSrc)(container)).toBe(`http://${thoughtSpotHost}/?embedApp=true&hostAppUrl=local-host&viewPortHeight=768&viewPortWidth=1024&sdkVersion=${package_json_1.version}&authType=None&blockNonEmbedFullAppAccess=true&hideAction=[%22${types_1.Action.ReportError}%22]&preAuthCache=true&overrideConsoleLogs=true&clientLogLevel=ERROR&dataSources=[%22test%22]&searchTokenString=%5Brevenue%5D&executeSearch=true&useLastSelectedSources=false&isSearchEmbed=true#/embed/search-bar-embed`);
        });
    });
    describe('SpotterMessage', () => {
        const mockMessage = {
            sessionId: "session123",
            genNo: 1,
            acSessionId: "acSession123",
            acGenNo: 2,
            worksheetId: "worksheet123",
            convId: "conv123",
            messageId: "message123"
        };
        it('Should render the SpotterMessage component with required props', async () => {
            const { container } = (0, react_2.render)(react_1.default.createElement(index_1.SpotterMessage, { message: mockMessage }));
            await (0, react_2.waitFor)(() => (0, test_utils_1.getIFrameEl)(container));
            expect((0, test_utils_1.getIFrameEl)(container)).not.toBe(null);
            expect((0, test_utils_1.getIFrameSrc)(container)).toContain('sessionId=session123');
            expect((0, test_utils_1.getIFrameSrc)(container)).toContain('genNo=1');
            expect((0, test_utils_1.getIFrameSrc)(container)).toContain('acSessionId=acSession123');
            expect((0, test_utils_1.getIFrameSrc)(container)).toContain('acGenNo=2');
        });
        it('Should render the SpotterMessage component with optional query', async () => {
            const { container } = (0, react_2.render)(react_1.default.createElement(index_1.SpotterMessage, { message: mockMessage, query: "show me sales" }));
            await (0, react_2.waitFor)(() => (0, test_utils_1.getIFrameEl)(container));
            expect((0, test_utils_1.getIFrameEl)(container)).not.toBe(null);
            expect((0, test_utils_1.getIFrameSrc)(container)).toContain('sessionId=session123');
        });
        it('Should have the correct container element with className', async () => {
            const { container } = (0, react_2.render)(react_1.default.createElement(index_1.SpotterMessage, { message: mockMessage, className: "custom-class" }));
            await (0, react_2.waitFor)(() => (0, test_utils_1.getIFrameEl)(container));
            expect((0, test_utils_1.getIFrameEl)(container).parentElement.classList.contains('custom-class')).toBe(true);
        });
        // Note: insertAsSibling is not supported for SpotterMessage as it's not part of the allowed props
    });
    describe('Component Factory Coverage', () => {
        it('Should test basic component creation', () => {
            expect(() => {
                (0, react_2.render)(react_1.default.createElement(index_1.LiveboardEmbed, { liveboardId: "test" }));
            }).not.toThrow();
            expect(() => {
                (0, react_2.render)(react_1.default.createElement(index_1.SearchEmbed, { dataSource: "test" }));
            }).not.toThrow();
            expect(() => {
                (0, react_2.render)(react_1.default.createElement(index_1.AppEmbed, { showPrimaryNavbar: false }));
            }).not.toThrow();
        });
        it('Should test component factory existence', () => {
            expect(index_1.PreRenderedLiveboardEmbed).toBeDefined();
            expect(index_1.PreRenderedSearchEmbed).toBeDefined();
            expect(index_1.PreRenderedAppEmbed).toBeDefined();
            expect(typeof index_1.PreRenderedLiveboardEmbed).toBe('object');
            expect(typeof index_1.PreRenderedSearchEmbed).toBe('object');
            expect(typeof index_1.PreRenderedAppEmbed).toBe('object');
        });
    });
    describe('Components with insertAsSibling', () => {
        it('Should render LiveboardEmbed with insertAsSibling', async () => {
            var _a;
            const { container } = (0, react_2.render)(react_1.default.createElement(index_1.LiveboardEmbed, { liveboardId: "test-liveboard", insertAsSibling: true }));
            await (0, react_2.waitFor)(() => (0, test_utils_1.getIFrameEl)(container));
            expect(container.querySelector('span')).not.toBe(null);
            expect((_a = container.querySelector('span')) === null || _a === void 0 ? void 0 : _a.style.position).toBe('absolute');
        });
        it('Should render SearchEmbed with insertAsSibling', async () => {
            var _a;
            const { container } = (0, react_2.render)(react_1.default.createElement(index_1.SearchEmbed, { dataSource: "test-datasource", insertAsSibling: true }));
            await (0, react_2.waitFor)(() => (0, test_utils_1.getIFrameEl)(container));
            expect(container.querySelector('span')).not.toBe(null);
            expect((_a = container.querySelector('span')) === null || _a === void 0 ? void 0 : _a.style.position).toBe('absolute');
        });
        it('Should render AppEmbed with insertAsSibling', async () => {
            var _a;
            const { container } = (0, react_2.render)(react_1.default.createElement(index_1.AppEmbed, { showPrimaryNavbar: false, insertAsSibling: true }));
            await (0, react_2.waitFor)(() => (0, test_utils_1.getIFrameEl)(container));
            expect(container.querySelector('span')).not.toBe(null);
            expect((_a = container.querySelector('span')) === null || _a === void 0 ? void 0 : _a.style.position).toBe('absolute');
        });
        it('Should render SearchBarEmbed with insertAsSibling', async () => {
            var _a;
            const { container } = (0, react_2.render)(react_1.default.createElement(index_1.SearchBarEmbed, { dataSource: "test-datasource", insertAsSibling: true }));
            await (0, react_2.waitFor)(() => (0, test_utils_1.getIFrameEl)(container));
            expect(container.querySelector('span')).not.toBe(null);
            expect((_a = container.querySelector('span')) === null || _a === void 0 ? void 0 : _a.style.position).toBe('absolute');
        });
        it('Should render components with both insertAsSibling and className', async () => {
            const { container } = (0, react_2.render)(react_1.default.createElement(index_1.LiveboardEmbed, { liveboardId: "test-liveboard", insertAsSibling: true, className: "custom-class" }));
            await (0, react_2.waitFor)(() => (0, test_utils_1.getIFrameEl)(container));
            expect(container.querySelector('span')).not.toBe(null);
            expect((0, test_utils_1.getIFrameEl)(container).classList.contains('custom-class')).toBe(true);
        });
    });
    describe('useSpotterAgent', () => {
        it('Should return an object with sendMessage function', () => {
            const TestComponent = () => {
                const spotterAgent = (0, index_1.useSpotterAgent)({ worksheetId: 'test-worksheet' });
                expect(typeof spotterAgent).toBe('object');
                expect(typeof spotterAgent.sendMessage).toBe('function');
                return react_1.default.createElement("div", null, "Test");
            };
            (0, react_2.render)(react_1.default.createElement(TestComponent, null));
        });
        it('Should have proper sendMessage callback structure', () => {
            const TestComponent = () => {
                const { sendMessage } = (0, index_1.useSpotterAgent)({ worksheetId: 'test-worksheet' });
                // Test that sendMessage is a function that accepts a string
                expect(typeof sendMessage).toBe('function');
                expect(sendMessage.length).toBe(1); // Should accept one parameter
                return react_1.default.createElement("div", null, "Test");
            };
            (0, react_2.render)(react_1.default.createElement(TestComponent, null));
        });
        it('Should return error when service is not initialized', async () => {
            let sendMessageResult;
            const TestComponent = () => {
                const { sendMessage } = (0, index_1.useSpotterAgent)({ worksheetId: 'test-worksheet' });
                // Call sendMessage immediately before service has time to initialize
                sendMessageResult = sendMessage('test query');
                return react_1.default.createElement("div", null, "Test");
            };
            (0, react_2.render)(react_1.default.createElement(TestComponent, null));
            const result = await sendMessageResult;
            expect(result).toEqual({
                error: expect.any(Error)
            });
            expect(result.error.message).toBe('SpotterAgent not initialized');
        });
        it('Should call sendMessage and handle async behavior', async () => {
            let sendMessageFunction;
            const TestComponent = () => {
                const { sendMessage } = (0, index_1.useSpotterAgent)({ worksheetId: 'test-worksheet' });
                sendMessageFunction = sendMessage;
                return react_1.default.createElement("div", null, "Test");
            };
            (0, react_2.render)(react_1.default.createElement(TestComponent, null));
            // Test that sendMessage is a function
            expect(typeof sendMessageFunction).toBe('function');
            // Call sendMessage - should not throw
            expect(() => {
                sendMessageFunction('test query');
            }).not.toThrow();
        });
        it('Should handle multiple calls to sendMessage', async () => {
            let sendMessageFunction;
            const TestComponent = () => {
                const { sendMessage } = (0, index_1.useSpotterAgent)({ worksheetId: 'test-worksheet' });
                sendMessageFunction = sendMessage;
                return react_1.default.createElement("div", null, "Test");
            };
            (0, react_2.render)(react_1.default.createElement(TestComponent, null));
            // Multiple calls should not throw
            expect(() => {
                sendMessageFunction('query 1');
                sendMessageFunction('query 2');
                sendMessageFunction('query 3');
            }).not.toThrow();
        });
        it('Should handle config object changes', () => {
            const TestComponent = ({ config }) => {
                const { sendMessage } = (0, index_1.useSpotterAgent)(config);
                expect(sendMessage).toBeDefined();
                return react_1.default.createElement("div", null, "Test");
            };
            const config1 = { worksheetId: 'test1' };
            const config2 = { worksheetId: 'test2' };
            const { rerender } = (0, react_2.render)(react_1.default.createElement(TestComponent, { config: config1 }));
            // Should not throw when config changes
            expect(() => {
                rerender(react_1.default.createElement(TestComponent, { config: config2 }));
            }).not.toThrow();
        });
        it('Should handle unmounting without errors', () => {
            const TestComponent = () => {
                const { sendMessage } = (0, index_1.useSpotterAgent)({ worksheetId: 'test-worksheet' });
                expect(sendMessage).toBeDefined();
                return react_1.default.createElement("div", null, "Test");
            };
            const { unmount } = (0, react_2.render)(react_1.default.createElement(TestComponent, null));
            // Should not throw when unmounting
            expect(() => {
                unmount();
            }).not.toThrow();
        });
        it('Should create stable hook structure', () => {
            let hookResult1, hookResult2;
            const TestComponent = ({ counter }) => {
                const result = (0, index_1.useSpotterAgent)({ worksheetId: 'test-worksheet' });
                if (counter === 1) {
                    hookResult1 = result;
                }
                else {
                    hookResult2 = result;
                }
                return react_1.default.createElement("div", null, "Test");
            };
            const { rerender } = (0, react_2.render)(react_1.default.createElement(TestComponent, { counter: 1 }));
            rerender(react_1.default.createElement(TestComponent, { counter: 2 }));
            // Both should have same structure
            expect(hookResult1).toEqual({ sendMessage: expect.any(Function) });
            expect(hookResult2).toEqual({ sendMessage: expect.any(Function) });
        });
        it('Should handle different worksheet IDs', () => {
            const TestComponent = ({ worksheetId }) => {
                const { sendMessage } = (0, index_1.useSpotterAgent)({ worksheetId });
                expect(sendMessage).toBeDefined();
                return react_1.default.createElement("div", null, "Test");
            };
            const { rerender } = (0, react_2.render)(react_1.default.createElement(TestComponent, { worksheetId: "worksheet1" }));
            // Should handle different worksheet IDs
            expect(() => {
                rerender(react_1.default.createElement(TestComponent, { worksheetId: "worksheet2" }));
                rerender(react_1.default.createElement(TestComponent, { worksheetId: "worksheet3" }));
            }).not.toThrow();
        });
        it('Should handle empty query strings', () => {
            let sendMessageFunction;
            const TestComponent = () => {
                const { sendMessage } = (0, index_1.useSpotterAgent)({ worksheetId: 'test-worksheet' });
                sendMessageFunction = sendMessage;
                return react_1.default.createElement("div", null, "Test");
            };
            (0, react_2.render)(react_1.default.createElement(TestComponent, null));
            // Should handle empty strings
            expect(() => {
                sendMessageFunction('');
                sendMessageFunction('   ');
            }).not.toThrow();
        });
        it('Should handle complex config objects', () => {
            const complexConfig = {
                worksheetId: 'test-worksheet',
                hiddenActions: [types_1.Action.ReportError],
                className: 'test-class',
                searchOptions: {
                    searchQuery: 'test query'
                }
            };
            const TestComponent = () => {
                const { sendMessage } = (0, index_1.useSpotterAgent)(complexConfig);
                expect(sendMessage).toBeDefined();
                return react_1.default.createElement("div", null, "Test");
            };
            // Should not throw with complex config
            expect(() => {
                (0, react_2.render)(react_1.default.createElement(TestComponent, null));
            }).not.toThrow();
        });
        it('Should maintain function identity across re-renders with same config', () => {
            let sendMessage1, sendMessage2;
            const TestComponent = ({ forceRender }) => {
                const { sendMessage } = (0, index_1.useSpotterAgent)({ worksheetId: 'test-worksheet' });
                if (forceRender === 1) {
                    sendMessage1 = sendMessage;
                }
                else {
                    sendMessage2 = sendMessage;
                }
                return react_1.default.createElement("div", null, "Test");
            };
            const { rerender } = (0, react_2.render)(react_1.default.createElement(TestComponent, { forceRender: 1 }));
            rerender(react_1.default.createElement(TestComponent, { forceRender: 2 }));
            // Functions should exist
            expect(sendMessage1).toBeDefined();
            expect(sendMessage2).toBeDefined();
            expect(typeof sendMessage1).toBe('function');
            expect(typeof sendMessage2).toBe('function');
        });
        it('Should handle sendMessage calls with null service ref', async () => {
            let capturedSendMessage;
            const TestComponent = () => {
                const { sendMessage } = (0, index_1.useSpotterAgent)({ worksheetId: 'test-worksheet' });
                capturedSendMessage = sendMessage;
                return react_1.default.createElement("div", null, "Test");
            };
            const { unmount } = (0, react_2.render)(react_1.default.createElement(TestComponent, null));
            // Unmount to trigger cleanup
            unmount();
            // Now call sendMessage after unmount - should return error
            const result = await capturedSendMessage('test query');
            expect(result).toEqual({
                error: expect.any(Error)
            });
        });
        it('Should test service ref cleanup on config change', () => {
            const TestComponent = ({ worksheetId }) => {
                const { sendMessage } = (0, index_1.useSpotterAgent)({ worksheetId });
                expect(sendMessage).toBeDefined();
                return react_1.default.createElement("div", null, "Test");
            };
            const { rerender } = (0, react_2.render)(react_1.default.createElement(TestComponent, { worksheetId: "worksheet1" }));
            // This should trigger the cleanup and create new service
            rerender(react_1.default.createElement(TestComponent, { worksheetId: "worksheet2" }));
            // Should still work after rerender
            expect(() => {
                rerender(react_1.default.createElement(TestComponent, { worksheetId: "worksheet3" }));
            }).not.toThrow();
        });
        it('Should test different config variations', () => {
            const configs = [
                { worksheetId: 'test1' },
                { worksheetId: 'test2', hiddenActions: [types_1.Action.ReportError] },
                { worksheetId: 'test3', className: 'test-class' },
                { worksheetId: 'test4', searchOptions: { searchQuery: 'test' } }
            ];
            configs.forEach((config, index) => {
                const TestComponent = () => {
                    const { sendMessage } = (0, index_1.useSpotterAgent)(config);
                    expect(sendMessage).toBeDefined();
                    return react_1.default.createElement("div", null,
                        "Test ",
                        index);
                };
                expect(() => {
                    const { unmount } = (0, react_2.render)(react_1.default.createElement(TestComponent, null));
                    unmount();
                }).not.toThrow();
            });
        });
        it('Should handle rapid config changes', () => {
            const TestComponent = ({ worksheetId }) => {
                const { sendMessage } = (0, index_1.useSpotterAgent)({ worksheetId });
                expect(sendMessage).toBeDefined();
                return react_1.default.createElement("div", null, "Test");
            };
            const { rerender } = (0, react_2.render)(react_1.default.createElement(TestComponent, { worksheetId: "worksheet1" }));
            // Rapid config changes to test cleanup logic
            for (let i = 2; i <= 10; i++) {
                rerender(react_1.default.createElement(TestComponent, { worksheetId: `worksheet${i}` }));
            }
            // Should still work after many changes
            expect(() => {
                rerender(react_1.default.createElement(TestComponent, { worksheetId: "final-worksheet" }));
            }).not.toThrow();
        });
        it('Should handle sendMessage with different query types', () => {
            let sendMessageFunction;
            const TestComponent = () => {
                const { sendMessage } = (0, index_1.useSpotterAgent)({ worksheetId: 'test-worksheet' });
                sendMessageFunction = sendMessage;
                return react_1.default.createElement("div", null, "Test");
            };
            (0, react_2.render)(react_1.default.createElement(TestComponent, null));
            // Test different query types
            const queries = [
                'simple query',
                'query with numbers 123',
                'query with special chars !@#$%',
                'very long query that might test different code paths in the system when processing',
                '',
                '   whitespace   ',
                'null',
                'undefined'
            ];
            queries.forEach(query => {
                expect(() => {
                    sendMessageFunction(query);
                }).not.toThrow();
            });
        });
        it('Should handle service ref cleanup when it already exists', () => {
            const TestComponent = ({ worksheetId }) => {
                const { sendMessage } = (0, index_1.useSpotterAgent)({ worksheetId });
                expect(sendMessage).toBeDefined();
                return react_1.default.createElement("div", null, "Test");
            };
            const { rerender } = (0, react_2.render)(react_1.default.createElement(TestComponent, { worksheetId: "worksheet1" }));
            // This should trigger the "if (serviceRef.current)" branch in useEffect
            rerender(react_1.default.createElement(TestComponent, { worksheetId: "worksheet1" }));
            rerender(react_1.default.createElement(TestComponent, { worksheetId: "worksheet2" }));
            rerender(react_1.default.createElement(TestComponent, { worksheetId: "worksheet3" }));
            // Multiple rapid changes should exercise the cleanup logic
            for (let i = 0; i < 5; i++) {
                rerender(react_1.default.createElement(TestComponent, { worksheetId: `worksheet${i}` }));
            }
        });
        it('Should test various config combinations to hit all branches', () => {
            const testConfigs = [
                { worksheetId: 'test1' },
                { worksheetId: 'test2', className: 'custom-class' },
                { worksheetId: 'test3', hiddenActions: [types_1.Action.ReportError] },
                { worksheetId: 'test4', searchOptions: { searchQuery: 'test' } },
                { worksheetId: 'test5', insertAsSibling: true },
                { worksheetId: 'test6', insertAsSibling: false },
            ];
            testConfigs.forEach((config, index) => {
                const TestComponent = () => {
                    const { sendMessage } = (0, index_1.useSpotterAgent)(config);
                    expect(sendMessage).toBeDefined();
                    return react_1.default.createElement("div", null,
                        "Test ",
                        index);
                };
                const { unmount } = (0, react_2.render)(react_1.default.createElement(TestComponent, null));
                unmount();
            });
        });
    });
    describe('Component Props and Functions', () => {
        it('Should have PreRenderedLiveboardEmbed component', () => {
            expect(index_1.PreRenderedLiveboardEmbed).toBeDefined();
            expect(typeof index_1.PreRenderedLiveboardEmbed).toBe('object');
        });
        it('Should have useInit hook', () => {
            expect(typeof index_1.useInit).toBe('function');
        });
        it('Should test basic component factory patterns', () => {
            // Test that components can be created without errors
            expect(() => {
                const TestComponent = () => react_1.default.createElement("div", null, "Test");
                (0, react_2.render)(react_1.default.createElement(TestComponent, null));
            }).not.toThrow();
        });
    });
    describe('Hook Coverage', () => {
        it('Should have useInit function available', () => {
            expect(typeof index_1.useInit).toBe('function');
        });
        it('Should test useInit hook basic functionality', () => {
            const TestComponent = () => {
                const authEE = (0, index_1.useInit)({
                    thoughtSpotHost: 'localhost',
                    authType: index_2.AuthType.None
                });
                expect(authEE).toBeDefined();
                expect(authEE.current).toBeDefined();
                return react_1.default.createElement("div", null, "Test");
            };
            (0, react_2.render)(react_1.default.createElement(TestComponent, null));
        });
        it('Should handle useInit with different config changes', () => {
            const TestComponent = ({ host }) => {
                const authEE = (0, index_1.useInit)({
                    thoughtSpotHost: host,
                    authType: index_2.AuthType.None
                });
                expect(authEE).toBeDefined();
                return react_1.default.createElement("div", null, "Test");
            };
            const { rerender } = (0, react_2.render)(react_1.default.createElement(TestComponent, { host: "localhost" }));
            // Change config to test useDeepCompareEffect
            rerender(react_1.default.createElement(TestComponent, { host: "localhost2" }));
            rerender(react_1.default.createElement(TestComponent, { host: "localhost3" }));
        });
        it('Should test useInit with complex config objects', () => {
            const TestComponent = () => {
                const authEE = (0, index_1.useInit)({
                    thoughtSpotHost: 'localhost',
                    authType: index_2.AuthType.None,
                    suppressNoCookieAccessAlert: true,
                    suppressErrorAlerts: true
                });
                expect(authEE).toBeDefined();
                return react_1.default.createElement("div", null, "Test");
            };
            (0, react_2.render)(react_1.default.createElement(TestComponent, null));
        });
    });
});
describe('allExports', () => {
    it('should have exports', () => {
        expect(typeof allExports).toBe('object');
    });
    it('should not have undefined exports', () => {
        Object.keys(allExports).forEach((exportKey) => expect(Boolean(allExports[exportKey]))
            .toBe(true));
    });
});
//# sourceMappingURL=index.spec.js.map