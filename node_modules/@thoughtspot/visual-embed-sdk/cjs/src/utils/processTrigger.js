"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processTrigger = exports.TRIGGER_TIMEOUT = exports.reload = void 0;
const errors_1 = require("../errors");
const types_1 = require("../types");
const logger_1 = require("../utils/logger");
const utils_1 = require("../utils");
const embedConfig_1 = require("../embed/embedConfig");
/**
 * Reloads the ThoughtSpot iframe.
 * @param iFrame
 */
const reload = (iFrame) => {
    const src = iFrame.src;
    iFrame.src = '';
    setTimeout(() => {
        iFrame.src = src;
    }, 100);
};
exports.reload = reload;
/**
 * Post iframe message.
 * @param iFrame
 * @param message
 * @param message.type
 * @param message.data
 * @param message.context
 * @param thoughtSpotHost
 * @param channel
 */
function postIframeMessage(iFrame, message, thoughtSpotHost, channel) {
    var _a;
    return (_a = iFrame.contentWindow) === null || _a === void 0 ? void 0 : _a.postMessage(message, thoughtSpotHost, [channel === null || channel === void 0 ? void 0 : channel.port2]);
}
exports.TRIGGER_TIMEOUT = 30000;
/**
 *
 * @param iFrame
 * @param messageType
 * @param thoughtSpotHost
 * @param data
 * @param context
 */
function processTrigger(iFrame, messageType, thoughtSpotHost, data, context) {
    return new Promise((res, rej) => {
        var _a;
        if (messageType === types_1.HostEvent.Reload) {
            (0, exports.reload)(iFrame);
            return res(null);
        }
        if (messageType === types_1.HostEvent.Present) {
            const embedConfig = (0, embedConfig_1.getEmbedConfig)();
            const disableFullscreenPresentation = (_a = embedConfig === null || embedConfig === void 0 ? void 0 : embedConfig.disableFullscreenPresentation) !== null && _a !== void 0 ? _a : true;
            if (!disableFullscreenPresentation) {
                (0, utils_1.handlePresentEvent)(iFrame);
            }
            else {
                logger_1.logger.warn('Fullscreen presentation mode is disabled. Set disableFullscreenPresentation: false to enable this feature.');
            }
        }
        const channel = new MessageChannel();
        channel.port1.onmessage = ({ data: responseData }) => {
            var _a;
            channel.port1.close();
            const error = (responseData === null || responseData === void 0 ? void 0 : responseData.error) || ((_a = responseData === null || responseData === void 0 ? void 0 : responseData.data) === null || _a === void 0 ? void 0 : _a.error);
            if (error) {
                rej(error);
            }
            else {
                res(responseData);
            }
        };
        // Close the messageChannel and resolve the promise if timeout.
        setTimeout(() => {
            channel.port1.close();
            res(new Error(errors_1.ERROR_MESSAGE.TRIGGER_TIMED_OUT));
        }, exports.TRIGGER_TIMEOUT);
        return postIframeMessage(iFrame, { type: messageType, data, context }, thoughtSpotHost, channel);
    });
}
exports.processTrigger = processTrigger;
//# sourceMappingURL=processTrigger.js.map