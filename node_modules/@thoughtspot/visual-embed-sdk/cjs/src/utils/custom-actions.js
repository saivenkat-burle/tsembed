"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCustomActions = void 0;
const tslib_1 = require("tslib");
const types_1 = require("../types");
const utils_1 = require("../utils");
const sortBy_1 = tslib_1.__importDefault(require("lodash/sortBy"));
const errors_1 = require("../errors");
const logger_1 = require("./logger");
/**
 * Configuration for custom action validation rules.
 * Defines allowed positions, metadata IDs, data model IDs, and fields for each target
 * type.
 *
 */
const customActionValidationConfig = {
    [types_1.CustomActionTarget.LIVEBOARD]: {
        positions: [types_1.CustomActionsPosition.PRIMARY, types_1.CustomActionsPosition.MENU],
        allowedMetadataIds: ['liveboardIds'],
        allowedDataModelIds: [],
        allowedFields: ['name', 'id', 'position', 'target', 'metadataIds', 'orgIds', 'groupIds'],
    },
    [types_1.CustomActionTarget.VIZ]: {
        positions: [types_1.CustomActionsPosition.MENU, types_1.CustomActionsPosition.PRIMARY, types_1.CustomActionsPosition.CONTEXTMENU],
        allowedMetadataIds: ['liveboardIds', 'vizIds', 'answerIds'],
        allowedDataModelIds: ['modelIds', 'modelColumnNames'],
        allowedFields: ['name', 'id', 'position', 'target', 'metadataIds', 'orgIds', 'groupIds', 'dataModelIds'],
    },
    [types_1.CustomActionTarget.ANSWER]: {
        positions: [types_1.CustomActionsPosition.MENU, types_1.CustomActionsPosition.PRIMARY, types_1.CustomActionsPosition.CONTEXTMENU],
        allowedMetadataIds: ['answerIds'],
        allowedDataModelIds: ['modelIds', 'modelColumnNames'],
        allowedFields: ['name', 'id', 'position', 'target', 'metadataIds', 'orgIds', 'groupIds', 'dataModelIds'],
    },
    [types_1.CustomActionTarget.SPOTTER]: {
        positions: [types_1.CustomActionsPosition.MENU, types_1.CustomActionsPosition.CONTEXTMENU],
        allowedMetadataIds: [],
        allowedDataModelIds: ['modelIds'],
        allowedFields: ['name', 'id', 'position', 'target', 'orgIds', 'groupIds', 'dataModelIds'],
    },
};
/**
 * Validates a single custom action based on its target type
 * @param action - The custom action to validate
 * @param primaryActionsPerTarget - Map to track primary actions per target
 * @returns CustomActionValidation with isValid flag and reason string
 *
 * @hidden
 */
const validateCustomAction = (action, primaryActionsPerTarget) => {
    const { id: actionId, target: targetType, position, metadataIds, dataModelIds } = action;
    // Check if target type is supported
    if (!customActionValidationConfig[targetType]) {
        const errorMessage = errors_1.CUSTOM_ACTIONS_ERROR_MESSAGE.UNSUPPORTED_TARGET(actionId, targetType);
        return { isValid: false, errors: [errorMessage] };
    }
    const config = customActionValidationConfig[targetType];
    const errors = [];
    // Validate position
    if (!(0, utils_1.arrayIncludesString)(config.positions, position)) {
        const supportedPositions = config.positions.join(', ');
        errors.push(errors_1.CUSTOM_ACTIONS_ERROR_MESSAGE.INVALID_POSITION(position, targetType, supportedPositions));
    }
    // Validate metadata IDs
    if (metadataIds) {
        const invalidMetadataIds = Object.keys(metadataIds).filter((key) => !(0, utils_1.arrayIncludesString)(config.allowedMetadataIds, key));
        if (invalidMetadataIds.length > 0) {
            const supportedMetadataIds = config.allowedMetadataIds.length > 0 ? config.allowedMetadataIds.join(', ') : 'none';
            errors.push(errors_1.CUSTOM_ACTIONS_ERROR_MESSAGE.INVALID_METADATA_IDS(targetType, invalidMetadataIds, supportedMetadataIds));
        }
    }
    // Validate data model IDs
    if (dataModelIds) {
        const invalidDataModelIds = Object.keys(dataModelIds).filter((key) => !(0, utils_1.arrayIncludesString)(config.allowedDataModelIds, key));
        if (invalidDataModelIds.length > 0) {
            const supportedDataModelIds = config.allowedDataModelIds.length > 0 ? config.allowedDataModelIds.join(', ') : 'none';
            errors.push(errors_1.CUSTOM_ACTIONS_ERROR_MESSAGE.INVALID_DATA_MODEL_IDS(targetType, invalidDataModelIds, supportedDataModelIds));
        }
    }
    // Validate allowed fields
    const actionKeys = Object.keys(action);
    const invalidFields = actionKeys.filter((key) => !(0, utils_1.arrayIncludesString)(config.allowedFields, key));
    if (invalidFields.length > 0) {
        const supportedFields = config.allowedFields.join(', ');
        errors.push(errors_1.CUSTOM_ACTIONS_ERROR_MESSAGE.INVALID_FIELDS(targetType, invalidFields, supportedFields));
    }
    return {
        isValid: errors.length === 0,
        errors,
    };
};
/**
 * Validates basic action structure and required fields
 * @param action - The action to validate
 * @returns Object containing validation result and missing fields
 *
 * @hidden
 */
const validateActionStructure = (action) => {
    if (!action || typeof action !== 'object') {
        return { isValid: false, missingFields: [] };
    }
    // Check for all missing required fields
    const missingFields = ['id', 'name', 'target', 'position'].filter(field => !action[field]);
    return { isValid: missingFields.length === 0, missingFields };
};
/**
 * Checks for duplicate IDs among actions
 * @param actions - Array of actions to check
 * @returns Object containing filtered actions and duplicate errors
 *
 * @hidden
 */
const filterDuplicateIds = (actions) => {
    const idMap = actions.reduce((map, action) => {
        const list = map.get(action.id) || [];
        list.push(action);
        map.set(action.id, list);
        return map;
    }, new Map());
    const { actions: actionsWithUniqueIds, errors } = Array.from(idMap.entries()).reduce((acc, [id, actionsWithSameId]) => {
        if (actionsWithSameId.length === 1) {
            acc.actions.push(actionsWithSameId[0]);
        }
        else {
            // Keep the first action and add error for duplicates
            acc.actions.push(actionsWithSameId[0]);
            const duplicateNames = actionsWithSameId.slice(1).map(action => action.name);
            acc.errors.push(errors_1.CUSTOM_ACTIONS_ERROR_MESSAGE.DUPLICATE_IDS(id, duplicateNames, actionsWithSameId[0].name));
        }
        return acc;
    }, { actions: [], errors: [] });
    return { actions: actionsWithUniqueIds, errors };
};
/**
 * Validates and processes custom actions
 * @param customActions - Array of custom actions to validate
 * @returns Object containing valid actions and any validation errors
 */
const getCustomActions = (customActions) => {
    const errors = [];
    const primaryActionsPerTarget = new Map();
    if (!customActions || !Array.isArray(customActions)) {
        return { actions: [], errors: [] };
    }
    // Step 1: Handle invalid actions first (null, undefined, missing required
    // fields)
    const validActions = customActions.filter(action => {
        const validation = validateActionStructure(action);
        if (!validation.isValid) {
            if (!action || typeof action !== 'object') {
                errors.push(errors_1.CUSTOM_ACTIONS_ERROR_MESSAGE.INVALID_ACTION_OBJECT);
            }
            else {
                errors.push(errors_1.CUSTOM_ACTIONS_ERROR_MESSAGE.MISSING_REQUIRED_FIELDS(action.id, validation.missingFields));
            }
            return false;
        }
        return true;
    });
    // Step 2: Check for duplicate IDs among valid actions
    const { actions: actionsWithUniqueIds, errors: duplicateErrors } = filterDuplicateIds(validActions);
    // Add duplicate errors to the errors array
    duplicateErrors.forEach(error => errors.push(error));
    // Step 3: Validate actions with unique IDs
    const finalValidActions = [];
    actionsWithUniqueIds.forEach((action) => {
        const { isValid, errors: validationErrors } = validateCustomAction(action, primaryActionsPerTarget);
        validationErrors.forEach(error => errors.push(error));
        if (isValid) {
            finalValidActions.push(action);
        }
    });
    // Step 4: Collect warnings for long custom action names
    const MAX_ACTION_NAME_LENGTH = 30;
    const warnings = finalValidActions
        .filter(action => action.name.length > MAX_ACTION_NAME_LENGTH)
        .map(action => `Custom action name '${action.name}' exceeds ${MAX_ACTION_NAME_LENGTH} characters. This may cause display or truncation issues in the UI.`);
    if (warnings.length > 0) {
        logger_1.logger.warn(warnings);
    }
    const sortedActions = (0, sortBy_1.default)(finalValidActions, (a) => a.name.toLocaleLowerCase());
    return {
        actions: sortedActions,
        errors: errors,
    };
};
exports.getCustomActions = getCustomActions;
//# sourceMappingURL=custom-actions.js.map