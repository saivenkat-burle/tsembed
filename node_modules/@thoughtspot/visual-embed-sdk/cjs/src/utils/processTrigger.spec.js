"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const _processTriggerInstance = tslib_1.__importStar(require("./processTrigger"));
const types_1 = require("../types");
const test_utils_1 = require("../test/test-utils");
const logger_1 = require("./logger");
const utilsModule = tslib_1.__importStar(require("../utils"));
const embedConfigModule = tslib_1.__importStar(require("../embed/embedConfig"));
describe('Unit test for processTrigger', () => {
    const iFrame = {
        contentWindow: {
            postMessage: jest.fn(),
        },
    };
    beforeEach(() => {
        jest.clearAllMocks();
    });
    test('when hostevent is reload, reload function should be called with iFrame', async () => {
        jest.useFakeTimers();
        const iFrameElement = document.createElement('iframe');
        const html = '<body>Foo</body>';
        iFrameElement.src = `data:text/html;charset=utf-8,${encodeURI(html)}`;
        const divFrame = document.createElement('div');
        divFrame.appendChild(iFrameElement);
        const messageType = types_1.HostEvent.Reload;
        const thoughtSpotHost = 'http://localhost:3000';
        const spyReload = jest.spyOn(_processTriggerInstance, 'reload');
        const data = {};
        _processTriggerInstance.processTrigger(iFrameElement, messageType, thoughtSpotHost, data);
        jest.advanceTimersByTime(200);
        expect(spyReload).toHaveBeenCalledWith(iFrameElement);
    });
    test('when hostevent is search, postMessage should be called', async () => {
        const messageType = types_1.HostEvent.Search;
        const thoughtSpotHost = 'http://localhost:3000';
        const data = {};
        (0, test_utils_1.mockMessageChannel)();
        const triggerPromise = _processTriggerInstance.processTrigger(iFrame, messageType, thoughtSpotHost, data);
        expect(iFrame.contentWindow.postMessage).toHaveBeenCalled();
        const res = {
            data: {
                test: '123',
            },
        };
        test_utils_1.messageChannelMock.port1.onmessage(res);
        expect(test_utils_1.messageChannelMock.port1.close).toHaveBeenCalled();
        expect(triggerPromise).resolves.toEqual(res.data);
    });
    test('Reject promise if error returned', async () => {
        const messageType = types_1.HostEvent.Search;
        const thoughtSpotHost = 'http://localhost:3000';
        const data = {};
        (0, test_utils_1.mockMessageChannel)();
        const triggerPromise = _processTriggerInstance.processTrigger(iFrame, messageType, thoughtSpotHost, data);
        expect(iFrame.contentWindow.postMessage).toHaveBeenCalled();
        const res = {
            data: {
                error: 'error',
            },
        };
        test_utils_1.messageChannelMock.port1.onmessage(res);
        expect(test_utils_1.messageChannelMock.port1.close).toHaveBeenCalled();
        expect(triggerPromise).rejects.toEqual(res.data.error);
    });
    test('should handle null/undefined responseData without throwing', async () => {
        const messageType = types_1.HostEvent.Search;
        const thoughtSpotHost = 'http://localhost:3000';
        const data = {};
        (0, test_utils_1.mockMessageChannel)();
        const triggerPromise = _processTriggerInstance.processTrigger(iFrame, messageType, thoughtSpotHost, data);
        expect(iFrame.contentWindow.postMessage).toHaveBeenCalled();
        // Simulate a message with null responseData
        test_utils_1.messageChannelMock.port1.onmessage({ data: null });
        expect(test_utils_1.messageChannelMock.port1.close).toHaveBeenCalled();
        await expect(triggerPromise).resolves.toEqual(null);
    });
    test('should close channel.port1 when timeout exceeds TRIGGER_TIMEOUT', async () => {
        const messageType = types_1.HostEvent.Search;
        const thoughtSpotHost = 'http://localhost:3000';
        const data = {};
        (0, test_utils_1.mockMessageChannel)();
        const triggerPromise = _processTriggerInstance.processTrigger(iFrame, messageType, thoughtSpotHost, data);
        jest.advanceTimersByTime(_processTriggerInstance.TRIGGER_TIMEOUT);
        expect(test_utils_1.messageChannelMock.port1.close).toHaveBeenCalled();
        await expect(triggerPromise).resolves.toBeInstanceOf(Error);
    });
    describe('Present event with fullscreen presentation flag', () => {
        let mockHandlePresentEvent;
        let mockLoggerWarn;
        let mockGetEmbedConfig;
        beforeEach(() => {
            mockHandlePresentEvent = jest.spyOn(utilsModule, 'handlePresentEvent').mockImplementation(() => Promise.resolve(undefined));
            mockLoggerWarn = jest.spyOn(logger_1.logger, 'warn').mockImplementation(() => { });
            mockGetEmbedConfig = jest.spyOn(embedConfigModule, 'getEmbedConfig').mockImplementation(() => ({ disableFullscreenPresentation: false }));
        });
        afterEach(() => {
            mockHandlePresentEvent.mockReset();
            mockLoggerWarn.mockReset();
            mockGetEmbedConfig.mockReset();
        });
        test('should handle Present event when disableFullscreenPresentation is false (enabled)', () => {
            const mockConfig = {
                disableFullscreenPresentation: false,
            };
            mockGetEmbedConfig.mockReturnValue(mockConfig);
            const messageType = types_1.HostEvent.Present;
            const thoughtSpotHost = 'https://example.thoughtspot.com';
            const data = {};
            _processTriggerInstance.processTrigger(iFrame, messageType, thoughtSpotHost, data);
            expect(mockHandlePresentEvent).toHaveBeenCalledWith(iFrame);
        });
        test('should warn and not handle Present event when disableFullscreenPresentation is true (disabled)', () => {
            const mockConfig = {
                disableFullscreenPresentation: true,
            };
            mockGetEmbedConfig.mockReturnValue(mockConfig);
            const messageType = types_1.HostEvent.Present;
            const thoughtSpotHost = 'https://example.thoughtspot.com';
            const data = {};
            _processTriggerInstance.processTrigger(iFrame, messageType, thoughtSpotHost, data);
            expect(mockHandlePresentEvent).not.toHaveBeenCalled();
            expect(mockLoggerWarn).toHaveBeenCalledWith('Fullscreen presentation mode is disabled. Set disableFullscreenPresentation: false to enable this feature.');
        });
        test('should default to disabled when disableFullscreenPresentation is not provided', () => {
            const mockConfig = {};
            mockGetEmbedConfig.mockReturnValue(mockConfig);
            const messageType = types_1.HostEvent.Present;
            const thoughtSpotHost = 'https://example.thoughtspot.com';
            const data = {};
            _processTriggerInstance.processTrigger(iFrame, messageType, thoughtSpotHost, data);
            expect(mockHandlePresentEvent).not.toHaveBeenCalled();
            expect(mockLoggerWarn).toHaveBeenCalledWith('Fullscreen presentation mode is disabled. Set disableFullscreenPresentation: false to enable this feature.');
        });
    });
});
//# sourceMappingURL=processTrigger.spec.js.map