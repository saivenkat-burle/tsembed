"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const processDataInstance = tslib_1.__importStar(require("./processData"));
const auth = tslib_1.__importStar(require("../auth"));
const base = tslib_1.__importStar(require("../embed/base"));
const embedConfigInstance = tslib_1.__importStar(require("../embed/embedConfig"));
const types_1 = require("../types");
const sessionInfoService = tslib_1.__importStar(require("./sessionInfoService"));
const utilsModule = tslib_1.__importStar(require("../utils"));
describe('Unit test for process data', () => {
    beforeAll(() => {
        jest.spyOn(auth, 'postLoginService').mockImplementation(() => Promise.resolve(undefined));
        base.init({
            thoughtSpotHost: 'https://tshost',
            authType: types_1.AuthType.None,
        });
    });
    afterEach(() => {
        jest.resetAllMocks();
    });
    const thoughtSpotHost = 'http://localhost';
    test('ProcessData, when Action is CustomAction', async () => {
        const processedData = {
            type: types_1.EmbedEvent.CustomAction,
            data: {},
        };
        jest.spyOn(processDataInstance, 'processCustomAction').mockImplementation(async () => ({}));
        expect(processDataInstance.processEventData(types_1.EmbedEvent.CustomAction, processedData, thoughtSpotHost, null)).toEqual(expect.objectContaining({
            ...processedData,
            answerService: {
                answer: {},
                selectedPoints: undefined,
                session: undefined,
                thoughtSpotHost: 'http://localhost',
                tmlOverride: {},
            },
        }));
    });
    test('ProcessData, when Action is CustomAction with contextMenuPoints', async () => {
        const processedData = {
            type: types_1.EmbedEvent.CustomAction,
            data: {
                contextMenuPoints: {
                    selectedPoints: [{ x: 1, y: 2 }],
                },
            },
        };
        jest.spyOn(processDataInstance, 'processCustomAction').mockImplementation(async () => ({}));
        expect(processDataInstance.processEventData(types_1.EmbedEvent.CustomAction, processedData, thoughtSpotHost, null)).toEqual(expect.objectContaining({
            ...processedData,
            answerService: {
                answer: {},
                selectedPoints: [{ x: 1, y: 2 }],
                session: undefined,
                thoughtSpotHost: 'http://localhost',
                tmlOverride: {},
            },
        }));
    });
    test('ProcessData, when Action is non CustomAction', () => {
        const processedData = { type: types_1.EmbedEvent.Data };
        jest.spyOn(processDataInstance, 'processCustomAction').mockImplementation(async () => ({}));
        processDataInstance.processEventData(types_1.EmbedEvent.Data, processedData, thoughtSpotHost, null);
        expect(processDataInstance.processCustomAction).not.toHaveBeenCalled();
    });
    test('AuthInit', () => {
        const sessionInfo = {
            userGUID: '1234',
            mixpanelToken: 'abc123',
            isPublicUser: false,
        };
        const e = { type: types_1.EmbedEvent.AuthInit, data: sessionInfo };
        jest.spyOn(base, 'notifyAuthSuccess');
        jest.spyOn(sessionInfoService, 'getSessionInfo').mockImplementation(() => Promise.resolve(sessionInfo));
        expect(processDataInstance.processEventData(e.type, e, '', null)).toEqual({
            type: e.type,
            data: {
                userGUID: sessionInfo.userGUID,
            },
        });
        expect(base.notifyAuthSuccess).toHaveBeenCalled();
    });
    test('NoCookieAccess no suppress alert', () => {
        const e = { type: types_1.EmbedEvent.NoCookieAccess };
        jest.spyOn(base, 'notifyAuthFailure');
        jest.spyOn(embedConfigInstance, 'getEmbedConfig').mockReturnValue({
            loginFailedMessage: 'Hello',
            suppressNoCookieAccessAlert: false,
        });
        jest.spyOn(window, 'alert').mockImplementation(() => undefined);
        const el = {};
        expect(processDataInstance.processEventData(e.type, e, '', el)).toEqual({
            type: e.type,
        });
        expect(base.notifyAuthFailure).toHaveBeenCalledWith(auth.AuthFailureType.NO_COOKIE_ACCESS);
        expect(window.alert).toHaveBeenCalled();
        expect(el.innerHTML).toBe('Hello');
    });
    test('NoCookieAccess suppressAlert=true', () => {
        const e = { type: types_1.EmbedEvent.NoCookieAccess };
        jest.spyOn(base, 'notifyAuthFailure');
        jest.spyOn(embedConfigInstance, 'getEmbedConfig').mockReturnValue({
            loginFailedMessage: 'Hello',
            suppressNoCookieAccessAlert: true,
        });
        jest.spyOn(window, 'alert').mockReset();
        jest.spyOn(window, 'alert').mockImplementation(() => undefined);
        const el = {};
        expect(processDataInstance.processEventData(e.type, e, '', el)).toEqual({
            type: e.type,
        });
        expect(base.notifyAuthFailure).toHaveBeenCalledWith(auth.AuthFailureType.NO_COOKIE_ACCESS);
        expect(window.alert).not.toHaveBeenCalled();
        expect(el.innerHTML).toBe('Hello');
    });
    test('NoCookieAccess ignoreNoCookieAccess=true', () => {
        const e = { type: types_1.EmbedEvent.NoCookieAccess };
        jest.spyOn(base, 'notifyAuthFailure');
        jest.spyOn(embedConfigInstance, 'getEmbedConfig').mockReturnValue({
            loginFailedMessage: 'Hello',
            ignoreNoCookieAccess: true,
        });
        jest.spyOn(window, 'alert').mockReset();
        jest.spyOn(window, 'alert').mockImplementation(() => undefined);
        const el = {};
        expect(processDataInstance.processEventData(e.type, e, '', el)).toEqual({
            type: e.type,
        });
        expect(base.notifyAuthFailure).toHaveBeenCalledWith(auth.AuthFailureType.NO_COOKIE_ACCESS);
        expect(window.alert).not.toHaveBeenCalled();
        expect(el.innerHTML).not.toBe('Hello');
    });
    test('process authFailure', () => {
        const e = { type: types_1.EmbedEvent.AuthFailure };
        jest.spyOn(base, 'notifyAuthFailure');
        jest.spyOn(embedConfigInstance, 'getEmbedConfig').mockReturnValue({
            loginFailedMessage: 'Hello',
        });
        const el = {};
        expect(processDataInstance.processEventData(e.type, e, '', el)).toEqual({
            type: e.type,
        });
        expect(base.notifyAuthFailure).toHaveBeenCalledWith(auth.AuthFailureType.OTHER);
        expect(el.innerHTML).toBe('Hello');
    });
    test('process authFailure AuthType=None', () => {
        const e = { type: types_1.EmbedEvent.AuthFailure };
        jest.spyOn(base, 'notifyAuthFailure');
        jest.spyOn(embedConfigInstance, 'getEmbedConfig').mockReturnValue({
            loginFailedMessage: 'Hello',
            authType: types_1.AuthType.None,
        });
        const el = {};
        expect(processDataInstance.processEventData(e.type, e, '', el)).toEqual({
            type: e.type,
        });
        expect(base.notifyAuthFailure).not.toHaveBeenCalled();
        expect(el.innerHTML).not.toBe('Hello');
    });
    test('process authLogout', () => {
        jest.spyOn(embedConfigInstance, 'getEmbedConfig').mockRestore();
        base.init({
            loginFailedMessage: 'Hello',
            autoLogin: true,
            thoughtSpotHost: 'https://tshost',
            authType: types_1.AuthType.None,
        });
        const e = { type: types_1.EmbedEvent.AuthLogout };
        jest.spyOn(base, 'notifyLogout');
        const el = {};
        expect(processDataInstance.processEventData(e.type, e, '', el)).toEqual({
            type: e.type,
        });
        expect(base.notifyLogout).toHaveBeenCalled();
        expect(el.innerHTML).toBe('Hello');
        expect(embedConfigInstance.getEmbedConfig().autoLogin).toBe(false);
    });
    test('process authFailure AuthType=None', () => {
        const e = { type: types_1.EmbedEvent.AuthFailure };
        jest.spyOn(embedConfigInstance, 'getEmbedConfig').mockReturnValue({
            loginFailedMessage: 'Hello',
            authType: types_1.AuthType.EmbeddedSSO,
            disableLoginFailurePage: true,
        });
        const el = {};
        expect(processDataInstance.processEventData(e.type, e, '', el)).toEqual({
            type: e.type,
        });
        expect(base.notifyAuthFailure).not.toHaveBeenCalled();
        expect(el.innerHTML).not.toBe('Hello');
    });
    test('process authFailure AuthType=TrustedAuthToken and autoLogin true', () => {
        const e = { type: types_1.EmbedEvent.AuthFailure };
        jest.spyOn(base, 'notifyAuthFailure');
        jest.spyOn(embedConfigInstance, 'getEmbedConfig').mockReturnValue({
            loginFailedMessage: 'Hello',
            authType: types_1.AuthType.TrustedAuthToken,
            autoLogin: true,
        });
        const el = {};
        expect(processDataInstance.processEventData(e.type, e, '', el)).toEqual({
            type: e.type,
        });
        expect(base.notifyAuthFailure).toHaveBeenCalledWith(auth.AuthFailureType.IDLE_SESSION_TIMEOUT);
        expect(el.innerHTML).toBe('Hello');
    });
    test('process authFailure with TrustedAuthTokenCookieless and autoLogin', () => {
        const e = { type: types_1.EmbedEvent.AuthFailure };
        jest.spyOn(base, 'notifyAuthFailure');
        jest.spyOn(embedConfigInstance, 'getEmbedConfig').mockReturnValue({
            loginFailedMessage: 'Hello',
            authType: types_1.AuthType.TrustedAuthTokenCookieless,
            autoLogin: true,
        });
        const el = {};
        expect(processDataInstance.processEventData(e.type, e, '', el)).toEqual({
            type: e.type,
        });
        expect(base.notifyAuthFailure).toHaveBeenCalledWith(auth.AuthFailureType.IDLE_SESSION_TIMEOUT);
        expect(el.innerHTML).toBe('Hello');
    });
    test('should handle ExitPresentMode when disableFullscreenPresentation is false (enabled)', () => {
        const mockConfig = {
            disableFullscreenPresentation: false,
        };
        const mockHandleExitPresentMode = jest.spyOn(utilsModule, 'handleExitPresentMode').mockImplementation(() => Promise.resolve(undefined));
        jest.spyOn(embedConfigInstance, 'getEmbedConfig').mockReturnValue(mockConfig);
        const processedData = {
            type: types_1.EmbedEvent.ExitPresentMode,
            data: {},
        };
        processDataInstance.processEventData(types_1.EmbedEvent.ExitPresentMode, processedData, thoughtSpotHost, null);
        expect(mockHandleExitPresentMode).toHaveBeenCalled();
        mockHandleExitPresentMode.mockReset();
    });
    test('should handle ClearInfoCache', () => {
        const mockResetCachedPreauthInfo = jest.spyOn(sessionInfoService, 'resetCachedPreauthInfo').mockImplementation(() => { });
        const mockResetCachedSessionInfo = jest.spyOn(sessionInfoService, 'resetCachedSessionInfo').mockImplementation(() => { });
        const processedData = {
            type: types_1.EmbedEvent.CLEAR_INFO_CACHE,
            data: {},
        };
        processDataInstance.processEventData(types_1.EmbedEvent.CLEAR_INFO_CACHE, processedData, thoughtSpotHost, null);
        expect(mockResetCachedPreauthInfo).toHaveBeenCalled();
        expect(mockResetCachedSessionInfo).toHaveBeenCalled();
    });
});
//# sourceMappingURL=processData.spec.js.map