"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processEventData = exports.processAuthFailure = exports.processCustomAction = void 0;
const embedConfig_1 = require("../embed/embedConfig");
const base_1 = require("../embed/base");
const auth_1 = require("../auth");
const types_1 = require("../types");
const answerService_1 = require("./graphql/answerService/answerService");
const authToken_1 = require("../authToken");
const errors_1 = require("../errors");
const utils_1 = require("../utils");
const sessionInfoService_1 = require("./sessionInfoService");
/**
 * Process the ExitPresentMode event and handle default fullscreen exit
 * @param e - The event data
 */
function processExitPresentMode(e) {
    var _a;
    const embedConfig = (0, embedConfig_1.getEmbedConfig)();
    const disableFullscreenPresentation = (_a = embedConfig === null || embedConfig === void 0 ? void 0 : embedConfig.disableFullscreenPresentation) !== null && _a !== void 0 ? _a : true;
    if (!disableFullscreenPresentation) {
        (0, utils_1.handleExitPresentMode)();
    }
}
/**
 * Clears the cached preauth and session info.
 */
function processClearInfoCache() {
    (0, sessionInfoService_1.resetCachedPreauthInfo)();
    (0, sessionInfoService_1.resetCachedSessionInfo)();
}
/**
 *
 * @param e
 * @param thoughtSpotHost
 */
function processCustomAction(e, thoughtSpotHost) {
    const { session, embedAnswerData, contextMenuPoints } = e.data;
    const answerService = new answerService_1.AnswerService(session, embedAnswerData || {}, thoughtSpotHost, contextMenuPoints === null || contextMenuPoints === void 0 ? void 0 : contextMenuPoints.selectedPoints);
    return {
        ...e,
        answerService,
    };
}
exports.processCustomAction = processCustomAction;
/**
 * Responds to AuthInit sent from host signifying successful authentication in host.
 * @param e
 * @returns {any}
 */
function processAuthInit(e) {
    var _a, _b;
    (0, base_1.notifyAuthSuccess)();
    // Expose only allowed details (eg: userGUID) back to SDK users.
    return {
        ...e,
        data: {
            userGUID: ((_a = e.data) === null || _a === void 0 ? void 0 : _a.userGUID) || ((_b = e.payload) === null || _b === void 0 ? void 0 : _b.userGUID),
        },
    };
}
/**
 *
 * @param e
 * @param containerEl
 */
function processNoCookieAccess(e, containerEl) {
    const { loginFailedMessage, suppressNoCookieAccessAlert, ignoreNoCookieAccess, suppressErrorAlerts, } = (0, embedConfig_1.getEmbedConfig)();
    if (!ignoreNoCookieAccess) {
        if (!suppressNoCookieAccessAlert && !suppressErrorAlerts) {
            // eslint-disable-next-line no-alert
            alert(errors_1.ERROR_MESSAGE.THIRD_PARTY_COOKIE_BLOCKED_ALERT);
        }
        // eslint-disable-next-line no-param-reassign
        containerEl.innerHTML = loginFailedMessage;
    }
    (0, base_1.notifyAuthFailure)(auth_1.AuthFailureType.NO_COOKIE_ACCESS);
    return e;
}
/**
 *
 * @param e
 * @param containerEl
 */
function processAuthFailure(e, containerEl) {
    var _a;
    const { loginFailedMessage, authType, disableLoginFailurePage, autoLogin, } = (0, embedConfig_1.getEmbedConfig)();
    const isEmbeddedSSO = authType === types_1.AuthType.EmbeddedSSO;
    const isTrustedAuth = authType === types_1.AuthType.TrustedAuthToken || authType === types_1.AuthType.TrustedAuthTokenCookieless;
    const isEmbeddedSSOInfoFailure = isEmbeddedSSO && ((_a = e === null || e === void 0 ? void 0 : e.data) === null || _a === void 0 ? void 0 : _a.type) === auth_1.AuthFailureType.UNAUTHENTICATED_FAILURE;
    if (autoLogin && isTrustedAuth) {
        // eslint-disable-next-line no-param-reassign
        containerEl.innerHTML = loginFailedMessage;
        (0, base_1.notifyAuthFailure)(auth_1.AuthFailureType.IDLE_SESSION_TIMEOUT);
    }
    else if (authType !== types_1.AuthType.None && !disableLoginFailurePage && !isEmbeddedSSOInfoFailure) {
        // eslint-disable-next-line no-param-reassign
        containerEl.innerHTML = loginFailedMessage;
        (0, base_1.notifyAuthFailure)(auth_1.AuthFailureType.OTHER);
    }
    (0, authToken_1.resetCachedAuthToken)();
    return e;
}
exports.processAuthFailure = processAuthFailure;
/**
 *
 * @param e
 * @param containerEl
 */
function processAuthLogout(e, containerEl) {
    const { loginFailedMessage } = (0, embedConfig_1.getEmbedConfig)();
    // eslint-disable-next-line no-param-reassign
    containerEl.innerHTML = loginFailedMessage;
    (0, authToken_1.resetCachedAuthToken)();
    (0, base_1.disableAutoLogin)();
    (0, base_1.notifyLogout)();
    return e;
}
/**
 *
 * @param type
 * @param e
 * @param thoughtSpotHost
 * @param containerEl
 */
function processEventData(type, eventData, thoughtSpotHost, containerEl) {
    switch (type) {
        case types_1.EmbedEvent.CustomAction:
            return processCustomAction(eventData, thoughtSpotHost);
        case types_1.EmbedEvent.AuthInit:
            return processAuthInit(eventData);
        case types_1.EmbedEvent.NoCookieAccess:
            return processNoCookieAccess(eventData, containerEl);
        case types_1.EmbedEvent.AuthFailure:
            return processAuthFailure(eventData, containerEl);
        case types_1.EmbedEvent.AuthLogout:
            return processAuthLogout(eventData, containerEl);
        case types_1.EmbedEvent.ExitPresentMode:
            return processExitPresentMode(eventData);
        case types_1.EmbedEvent.CLEAR_INFO_CACHE:
            return processClearInfoCache();
        default:
    }
    return eventData;
}
exports.processEventData = processEventData;
//# sourceMappingURL=processData.js.map