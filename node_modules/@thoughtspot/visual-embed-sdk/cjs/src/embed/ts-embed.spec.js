"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultParams = exports.defaultParamsWithoutHiddenActions = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("../utils");
const errors_1 = require("../errors");
const authToken_1 = require("../authToken");
const index_1 = require("../index");
const types_1 = require("../types");
const test_utils_1 = require("../test/test-utils");
const config = tslib_1.__importStar(require("../config"));
const embedConfig = tslib_1.__importStar(require("./embedConfig"));
const tsEmbedInstance = tslib_1.__importStar(require("./ts-embed"));
const mixpanelInstance = tslib_1.__importStar(require("../mixpanel-service"));
const authInstance = tslib_1.__importStar(require("../auth"));
const baseInstance = tslib_1.__importStar(require("./base"));
const mixpanel_service_1 = require("../mixpanel-service");
const authService = tslib_1.__importStar(require("../utils/authService"));
const logger_1 = require("../utils/logger");
const package_json_1 = require("../../package.json");
const search_1 = require("./search");
const processTrigger_1 = require("../utils/processTrigger");
const contracts_1 = require("./hostEventClient/contracts");
const sessionInfoService = tslib_1.__importStar(require("../utils/sessionInfoService"));
const authToken = tslib_1.__importStar(require("../authToken"));
const apiIntercept = tslib_1.__importStar(require("../api-intercept"));
const processData = tslib_1.__importStar(require("../utils/processData"));
jest.mock('../utils/processTrigger');
const mockProcessTrigger = processTrigger_1.processTrigger;
const mockHandleInterceptEvent = jest.spyOn(apiIntercept, 'handleInterceptEvent');
const defaultViewConfig = {
    frameParams: {
        width: 1280,
        height: 720,
    },
};
const pinboardId = 'eca215d4-0d2c-4a55-90e3-d81ef6848ae0';
const liveboardId = 'eca215d4-0d2c-4a55-90e3-d81ef6848ae0';
const tabId1 = 'eca215d4-0d2c-4a55-90e3-d81ef6848ae0';
const tabId2 = 'eca215d4-0d2c-4a55-90e3-d81ef6848ae0';
const thoughtSpotHost = 'tshost';
const defaultParamsPost = '';
exports.defaultParamsWithoutHiddenActions = `hostAppUrl=local-host&viewPortHeight=768&viewPortWidth=1024&sdkVersion=${package_json_1.version}&authType=${index_1.AuthType.None}&blockNonEmbedFullAppAccess=true`;
exports.defaultParams = `&${exports.defaultParamsWithoutHiddenActions}&hideAction=[%22${types_1.Action.ReportError}%22]`;
const hideBydefault = `&hideAction=${(0, test_utils_1.fixedEncodeURI)(JSON.stringify([types_1.Action.ReportError, ...search_1.HiddenActionItemByDefaultForSearchEmbed]))}`;
const defaultParamsWithHiddenActions = exports.defaultParamsWithoutHiddenActions + hideBydefault;
beforeAll(() => {
    jest.spyOn(window, 'alert').mockImplementation(() => { });
});
const customisations = {
    style: {
        customCSS: {},
    },
    content: {},
};
const customisationsView = {
    style: {
        customCSS: {},
    },
    content: {
        strings: {
            DATA: 'data',
        },
    },
};
const customVariablesForThirdPartyTools = {
    key1: '!@#',
    key2: '*%^',
};
const getMockAppInitPayload = (data) => {
    const defaultData = {
        customisations,
        authToken: '',
        hostConfig: undefined,
        runtimeFilterParams: null,
        runtimeParameterParams: null,
        hiddenHomeLeftNavItems: [],
        hiddenHomepageModules: [],
        hiddenListColumns: [],
        customActions: [],
        reorderedHomepageModules: [],
        customVariablesForThirdPartyTools,
        interceptTimeout: undefined,
        interceptUrls: [],
    };
    return {
        type: index_1.EmbedEvent.APP_INIT,
        data: {
            ...defaultData,
            ...data,
        },
    };
};
describe('Unit test case for ts embed', () => {
    const mockMixPanelEvent = jest.spyOn(mixpanelInstance, 'uploadMixpanelEvent');
    beforeEach(() => {
        document.body.innerHTML = (0, test_utils_1.getDocumentBody)();
    });
    afterEach(() => {
        jest.clearAllMocks();
        (0, authToken_1.resetCachedAuthToken)();
    });
    beforeAll(() => {
        jest.spyOn(authInstance, 'postLoginService').mockResolvedValue(undefined);
    });
    describe('Vaidate iframe properties', () => {
        beforeAll(() => {
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.None,
            });
        });
        test('should set proper allow policies', async () => {
            // we dont have origin specific policies so just checking if
            // policies are ending with ;
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            searchEmbed.render();
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                const policiesAdded = iframe.allow.split(' ');
                policiesAdded.forEach((policy) => {
                    expect(policy.endsWith(';')).toBe(true);
                });
            });
        });
        test('should get answer service', async () => {
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            searchEmbed.render();
            mockProcessTrigger.mockResolvedValue({ session: 'test' });
            await (0, test_utils_1.executeAfterWait)(async () => {
                expect(await searchEmbed.getAnswerService()).toBeInstanceOf(index_1.AnswerService);
            });
        });
        test('triggerUIPassThrough with params', async () => {
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            searchEmbed.render();
            mockProcessTrigger.mockResolvedValue({ session: 'test' });
            await (0, test_utils_1.executeAfterWait)(async () => {
                const payload = { newVizName: 'test' };
                await searchEmbed.triggerUIPassThrough(contracts_1.UIPassthroughEvent.PinAnswerToLiveboard, payload);
                expect(mockProcessTrigger).toHaveBeenCalledWith((0, test_utils_1.getIFrameEl)(), types_1.HostEvent.UIPassthrough, 'http://tshost', {
                    parameters: payload,
                    type: contracts_1.UIPassthroughEvent.PinAnswerToLiveboard,
                }, undefined);
            });
        });
        test('Host event with empty param', async () => {
            const liveboardEmbed = new index_1.LiveboardEmbed((0, test_utils_1.getRootEl)(), {
                liveboardId: '123',
                ...defaultViewConfig,
            });
            liveboardEmbed.render();
            mockProcessTrigger.mockResolvedValue({ session: 'test' });
            await (0, test_utils_1.executeAfterWait)(async () => {
                await liveboardEmbed.trigger(types_1.HostEvent.Save);
                expect(mockProcessTrigger).toHaveBeenCalledWith((0, test_utils_1.getIFrameEl)(), types_1.HostEvent.Save, 'http://tshost', {}, undefined);
            });
        });
        test('Host event with falsy param', async () => {
            const liveboardEmbed = new index_1.LiveboardEmbed((0, test_utils_1.getRootEl)(), {
                liveboardId: '123',
                ...defaultViewConfig,
            });
            liveboardEmbed.render();
            mockProcessTrigger.mockResolvedValue({ session: 'test' });
            await (0, test_utils_1.executeAfterWait)(async () => {
                await liveboardEmbed.trigger(types_1.HostEvent.Save, false);
                expect(mockProcessTrigger).toHaveBeenCalledWith((0, test_utils_1.getIFrameEl)(), types_1.HostEvent.Save, 'http://tshost', false, undefined);
            });
        });
        test('should set proper height, width and min-height to iframe', async () => {
            // we dont have origin specific policies so just checking if
            // policies are ending with ;
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            searchEmbed.render();
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                expect(iframe.style.width).toBe(`${defaultViewConfig.frameParams.width}px`);
                expect(iframe.style.height).toBe(`${defaultViewConfig.frameParams.height}px`);
                expect(iframe.style.minHeight).toBe(`${defaultViewConfig.frameParams.height}px`);
            });
        });
    });
    describe('AuthExpire embedEvent in cookieless authentication authType', () => {
        beforeAll(() => {
            jest.spyOn(authInstance, 'doCookielessTokenAuth').mockResolvedValueOnce(true);
            jest.spyOn(authService, 'verifyTokenService').mockResolvedValueOnce(true);
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                customizations: customisations,
                authType: index_1.AuthType.TrustedAuthTokenCookieless,
                getAuthToken: () => Promise.resolve('test_auth_token2'),
            });
        });
        test('check for new authToken based on getAuthToken function', async () => {
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.AuthExpire,
                data: {},
            };
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            jest.spyOn(baseInstance, 'notifyAuthFailure');
            jest.spyOn(baseInstance, 'handleAuth');
            searchEmbed.render();
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(baseInstance.notifyAuthFailure).toHaveBeenCalledWith(authInstance.AuthFailureType.EXPIRY);
                expect(baseInstance.handleAuth).not.toHaveBeenCalled();
                expect(mockPort.postMessage).toHaveBeenCalledWith({
                    type: index_1.EmbedEvent.AuthExpire,
                    data: { authToken: 'test_auth_token2' },
                });
            });
        });
        test('check for new authToken based on getAuthToken function', async () => {
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                customizations: customisations,
                authType: index_1.AuthType.TrustedAuthToken,
                getAuthToken: () => Promise.resolve('test_auth_token2'),
                autoLogin: true,
            });
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.AuthExpire,
                data: {},
            };
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            jest.spyOn(baseInstance, 'notifyAuthFailure');
            jest.spyOn(baseInstance, 'handleAuth');
            searchEmbed.render();
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(baseInstance.notifyAuthFailure).toHaveBeenCalledWith(authInstance.AuthFailureType.EXPIRY);
                expect(mockPort.postMessage).not.toHaveBeenCalledWith({
                    type: index_1.EmbedEvent.AuthExpire,
                    data: { authToken: 'test_auth_token2' },
                });
                expect(baseInstance.handleAuth).toHaveBeenCalled();
            });
        });
    });
    describe('Called Embed event status for start and end', () => {
        beforeAll(() => {
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.None,
                customizations: customisations,
                customVariablesForThirdPartyTools,
            });
        });
        test('verify Customisations', async () => {
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.APP_INIT,
                data: {},
            };
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            searchEmbed.render();
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(mockPort.postMessage).toHaveBeenCalledWith(getMockAppInitPayload({}));
            });
        });
        test('verify Customisations from viewConfig', async () => {
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.APP_INIT,
                data: {},
            };
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), {
                ...defaultViewConfig,
                customizations: customisationsView,
            });
            searchEmbed.render();
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(mockPort.postMessage).toHaveBeenCalledWith(getMockAppInitPayload({
                    customisations: customisationsView,
                }));
            });
        });
        test('hide home page modules from view Config should be part of app_init payload', async () => {
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.APP_INIT,
                data: {},
            };
            const mockedHiddenHomepageModules = [
                types_1.HomepageModule.MyLibrary,
                types_1.HomepageModule.Learning,
            ];
            const searchEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                ...defaultViewConfig,
                hiddenHomepageModules: mockedHiddenHomepageModules,
            });
            searchEmbed.render();
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(mockPort.postMessage).toHaveBeenCalledWith(getMockAppInitPayload({
                    hiddenHomepageModules: [types_1.HomepageModule.MyLibrary, types_1.HomepageModule.Learning],
                }));
            });
        });
        test('customVariablesForThirdPartyTools should be part of the app_init payload', async () => {
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.APP_INIT,
                data: {},
            };
            const searchEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                ...defaultViewConfig,
            });
            searchEmbed.render();
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(mockPort.postMessage).toHaveBeenCalledWith(getMockAppInitPayload({}));
            });
        });
        test('Reordering the home page modules from view Config should be part of app_init payload', async () => {
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.APP_INIT,
                data: {},
            };
            const mockedReorderedHomepageModules = [
                types_1.HomepageModule.MyLibrary,
                types_1.HomepageModule.Watchlist,
            ];
            const searchEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                ...defaultViewConfig,
                reorderedHomepageModules: mockedReorderedHomepageModules,
            });
            searchEmbed.render();
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(mockPort.postMessage).toHaveBeenCalledWith(getMockAppInitPayload({
                    reorderedHomepageModules: [types_1.HomepageModule.MyLibrary, types_1.HomepageModule.Watchlist],
                }));
            });
        });
        test('Runtime parameters from view Config should be part of app_init payload when excludeRuntimeParametsfromURL is true', async () => {
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.APP_INIT,
                data: {},
            };
            const mockRuntimeParameters = [
                {
                    name: 'color',
                    value: 'blue',
                },
            ];
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), {
                ...defaultViewConfig,
                excludeRuntimeParametersfromURL: true,
                runtimeParameters: mockRuntimeParameters,
            });
            searchEmbed.render();
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(mockPort.postMessage).toHaveBeenCalledWith(getMockAppInitPayload({
                    runtimeParameterParams: 'param1=color&paramVal1=blue',
                }));
            });
        });
        test('Runtime filters from view Config should be part of app_init payload when excludeRuntimeFiltersfromURL is true', async () => {
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.APP_INIT,
                data: {},
            };
            const mockRuntimeFilters = [
                {
                    columnName: 'color',
                    operator: types_1.RuntimeFilterOp.EQ,
                    values: ['blue'],
                },
            ];
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), {
                ...defaultViewConfig,
                excludeRuntimeFiltersfromURL: true,
                runtimeFilters: mockRuntimeFilters,
            });
            searchEmbed.render();
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(mockPort.postMessage).toHaveBeenCalledWith(getMockAppInitPayload({
                    runtimeFilterParams: 'col1=color&op1=EQ&val1=blue',
                }));
            });
        });
        test('Runtime filters from view Config should be not part of app_init payload when excludeRuntimeFiltersfromURL is undefined', async () => {
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.APP_INIT,
                data: {},
            };
            const mockRuntimeFilters = [
                {
                    columnName: 'color',
                    operator: types_1.RuntimeFilterOp.EQ,
                    values: ['blue'],
                },
            ];
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), {
                ...defaultViewConfig,
                runtimeFilters: mockRuntimeFilters,
                excludeRuntimeFiltersfromURL: undefined,
            });
            searchEmbed.render();
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(mockPort.postMessage).toHaveBeenCalledWith(getMockAppInitPayload({}));
            });
        });
        test('Runtime filters from view Config should not be part of app_init payload when excludeRuntimeFiltersfromURL is false', async () => {
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.APP_INIT,
                data: {},
            };
            const mockRuntimeFilters = [
                {
                    columnName: 'color',
                    operator: types_1.RuntimeFilterOp.EQ,
                    values: ['blue'],
                },
            ];
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), {
                ...defaultViewConfig,
                excludeRuntimeFiltersfromURL: false,
                runtimeFilters: mockRuntimeFilters,
            });
            searchEmbed.render();
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(mockPort.postMessage).toHaveBeenCalledWith(getMockAppInitPayload({}));
            });
        });
        test('homeLeftNav from view Config should be part of app_init payload', async () => {
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.APP_INIT,
                data: {},
            };
            const mockedHiddenHomeLeftNavItems = [
                types_1.HomeLeftNavItem.Home,
                types_1.HomeLeftNavItem.MonitorSubscription,
            ];
            const searchEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                ...defaultViewConfig,
                hiddenHomeLeftNavItems: mockedHiddenHomeLeftNavItems,
            });
            searchEmbed.render();
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(mockPort.postMessage).toHaveBeenCalledWith(getMockAppInitPayload({
                    hiddenHomeLeftNavItems: [types_1.HomeLeftNavItem.Home, types_1.HomeLeftNavItem.MonitorSubscription],
                }));
            });
        });
        test('when Embed event status have start status', (done) => {
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.Save,
                data: { answerId: '123' },
                status: 'start',
            };
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            searchEmbed
                .on(index_1.EmbedEvent.Save, (payload) => {
                expect(payload).toEqual(mockEmbedEventPayload);
                done();
            }, { start: true })
                .render();
            (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload);
            });
        });
        test('should not called post message, when Embed event status have start and start option as false', () => {
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.Save,
                data: { answerId: '123' },
                status: 'start',
            };
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            searchEmbed
                .on(index_1.EmbedEvent.Save, () => {
                logger_1.logger.log('non callable');
            })
                .render();
            (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                iframe.contentWindow.postMessage = jest.fn();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload);
                expect(iframe.contentWindow.postMessage).toHaveBeenCalledTimes(0);
            });
        });
        test('when Embed event status have end status', (done) => {
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.Save,
                data: { answerId: '123' },
                status: 'end',
            };
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            searchEmbed
                .on(index_1.EmbedEvent.Save, (payload) => {
                expect(payload).toEqual(mockEmbedEventPayload);
                done();
            })
                .render();
            (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload);
            }, 1000);
        });
        test('should not called post message, when Embed event status have end status and start is true', () => {
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.Save,
                data: { answerId: '123' },
                status: 'end',
            };
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            searchEmbed
                .on(index_1.EmbedEvent.Save, () => {
                logger_1.logger.log('non callable');
            }, { start: true })
                .render();
            (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                iframe.contentWindow.postMessage = jest.fn();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload);
                expect(iframe.contentWindow.postMessage).toHaveBeenCalledTimes(0);
            }, 1000);
        });
        test('should remove event listener when called off method', async () => {
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.Save,
                data: { answerId: '123' },
                status: 'end',
            };
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            const mockFn = jest.fn();
            searchEmbed.on(index_1.EmbedEvent.Save, mockFn).render();
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload);
            });
            searchEmbed.off(index_1.EmbedEvent.Save, mockFn);
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload);
            });
            expect(mockFn).toHaveBeenCalledTimes(1);
        });
    });
    describe('Appinit embedEvent in cookieless authentication authType', () => {
        beforeAll(() => {
            jest.spyOn(authInstance, 'doCookielessTokenAuth').mockResolvedValueOnce(true);
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                customizations: customisations,
                authType: index_1.AuthType.TrustedAuthTokenCookieless,
                getAuthToken: () => Promise.resolve('test_auth_token1'),
            });
        });
        afterEach(() => {
            baseInstance.reset();
        });
        test('check for authToken based on getAuthToken function', async () => {
            const a = jest.spyOn(authService, 'verifyTokenService');
            a.mockResolvedValue(true);
            // authVerifyMock.mockResolvedValue(true);
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.APP_INIT,
                data: {},
            };
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            searchEmbed.render();
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(mockPort.postMessage).toHaveBeenCalledWith(getMockAppInitPayload({
                    authToken: 'test_auth_token1',
                    customVariablesForThirdPartyTools: {},
                }));
            });
            jest.spyOn(authService, 'verifyTokenService').mockClear();
        });
    });
    describe('StringIDs and StringIDsUrl in customisations', () => {
        const customisationWithStringIds = {
            style: {
                customCSS: {},
            },
            content: {
                strings: {
                    Liveboard: 'Dashboard',
                },
                stringIDsUrl: 'https://sample-string-ids-url.com',
                stringIDs: {
                    'liveboard.header.title': 'Dashboard name',
                },
            },
        };
        beforeEach(() => {
            jest.spyOn(authInstance, 'doCookielessTokenAuth').mockResolvedValueOnce(true);
            jest.spyOn(authService, 'verifyTokenService').mockResolvedValue(true);
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                customizations: customisationWithStringIds,
                authType: index_1.AuthType.TrustedAuthTokenCookieless,
                getAuthToken: () => Promise.resolve('test_auth_token1'),
            });
        });
        afterEach(() => {
            baseInstance.reset();
            jest.clearAllMocks();
        });
        test('should pass stringIDsUrl and stringIDs in customisations during APP_INIT', async () => {
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.APP_INIT,
                data: {},
            };
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            searchEmbed.render();
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                expect(iframe.src).toContain('overrideStringIDsUrl=https://sample-string-ids-url.com');
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(mockPort.postMessage).toHaveBeenCalledWith(getMockAppInitPayload({
                    customisations: {
                        content: {
                            strings: {
                                Liveboard: 'Dashboard',
                            },
                            stringIDsUrl: 'https://sample-string-ids-url.com',
                            stringIDs: {
                                'liveboard.header.title': 'Dashboard name',
                            },
                        },
                        style: {
                            customCSS: {},
                            customCSSUrl: undefined,
                        },
                    },
                    authToken: 'test_auth_token1',
                    customVariablesForThirdPartyTools: {},
                }));
                const customisationContent = mockPort.postMessage.mock.calls[0][0].data.customisations.content;
                expect(customisationContent.stringIDsUrl)
                    .toBe('https://sample-string-ids-url.com');
                expect(customisationContent.stringIDs)
                    .toEqual({
                    'liveboard.header.title': 'Dashboard name',
                });
            });
        });
        test('should allow passing exposeTranslationIDs in viewConfig', async () => {
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.APP_INIT,
                data: {},
            };
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), { ...defaultViewConfig, exposeTranslationIDs: true });
            searchEmbed.render();
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                expect(iframe.src).toContain('exposeTranslationIDs=true');
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload, mockPort);
            });
        });
    });
    describe('getDefaultAppInitData with CustomActionsValidationResult', () => {
        beforeEach(() => {
            jest.spyOn(authInstance, 'doCookielessTokenAuth').mockResolvedValueOnce(true);
            jest.spyOn(authService, 'verifyTokenService').mockResolvedValue(true);
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.TrustedAuthTokenCookieless,
                getAuthToken: () => Promise.resolve('test_auth_token1'),
            });
        });
        afterEach(() => {
            baseInstance.reset();
            jest.clearAllMocks();
        });
        test('should handle valid custom actions and sort them by name in getDefaultAppInitData', async () => {
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.APP_INIT,
                data: {},
            };
            // Create a SearchEmbed with valid custom actions to test
            // CustomActionsValidationResult
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), {
                ...defaultViewConfig,
                customActions: [
                    {
                        id: 'action1',
                        name: 'Valid Action',
                        target: types_1.CustomActionTarget.LIVEBOARD,
                        position: types_1.CustomActionsPosition.PRIMARY,
                        metadataIds: { liveboardIds: ['lb123'] }
                    },
                    {
                        id: 'action2',
                        name: 'Another Valid Action',
                        target: types_1.CustomActionTarget.VIZ,
                        position: types_1.CustomActionsPosition.MENU,
                        metadataIds: { vizIds: ['viz456'] }
                    }
                ]
            });
            searchEmbed.render();
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(mockPort.postMessage).toHaveBeenCalledWith(getMockAppInitPayload({
                    customisations: {
                        content: {},
                        style: {
                            customCSS: {},
                            customCSSUrl: undefined,
                        },
                    },
                    authToken: 'test_auth_token1',
                    customActions: [
                        {
                            id: 'action2',
                            name: 'Another Valid Action',
                            target: types_1.CustomActionTarget.VIZ,
                            position: types_1.CustomActionsPosition.MENU,
                            metadataIds: { vizIds: ['viz456'] }
                        },
                        {
                            id: 'action1',
                            name: 'Valid Action',
                            target: types_1.CustomActionTarget.LIVEBOARD,
                            position: types_1.CustomActionsPosition.PRIMARY,
                            metadataIds: { liveboardIds: ['lb123'] }
                        }
                    ],
                    customVariablesForThirdPartyTools: {},
                }));
                // Verify that CustomActionsValidationResult structure is
                // correct
                const appInitData = mockPort.postMessage.mock.calls[0][0].data;
                expect(appInitData.customActions).toHaveLength(2);
                expect(appInitData.customActions).toEqual(expect.arrayContaining([
                    expect.objectContaining({
                        id: 'action1',
                        name: 'Valid Action',
                        target: types_1.CustomActionTarget.LIVEBOARD,
                        position: types_1.CustomActionsPosition.PRIMARY
                    }),
                    expect.objectContaining({
                        id: 'action2',
                        name: 'Another Valid Action',
                        target: types_1.CustomActionTarget.VIZ,
                        position: types_1.CustomActionsPosition.MENU
                    })
                ]));
                // Verify actions are sorted by name (alphabetically)
                expect(appInitData.customActions[0].name).toBe('Another Valid Action');
                expect(appInitData.customActions[1].name).toBe('Valid Action');
            });
        });
    });
    describe('Token fetch fails in cookieless authentication authType', () => {
        beforeEach(() => {
            jest.spyOn(authInstance, 'doCookielessTokenAuth').mockResolvedValueOnce(true);
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                customizations: customisations,
                authType: index_1.AuthType.TrustedAuthTokenCookieless,
                getAuthToken: () => Promise.reject(),
            });
            jest.spyOn(logger_1.logger, 'error').mockImplementation(() => { });
        });
        afterEach(() => {
            jest.clearAllMocks();
            baseInstance.reset();
        });
        test('should show login failure message if token failed during app_init', async () => {
            const a = jest.spyOn(authService, 'verifyTokenService');
            a.mockResolvedValue(true);
            // authVerifyMock.mockResolvedValue(true);
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.APP_INIT,
                data: {},
            };
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            searchEmbed.render();
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(mockPort.postMessage).not.toHaveBeenCalled();
                expect((0, test_utils_1.getRootEl)().innerHTML).toContain('Not logged in');
            });
            jest.spyOn(authService, 'verifyTokenService').mockClear();
        });
        test('should show login failure message if token failed during app_init prerender', async () => {
            const a = jest.spyOn(authService, 'verifyTokenService');
            a.mockResolvedValue(true);
            // authVerifyMock.mockResolvedValue(true);
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.APP_INIT,
                data: {},
            };
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), { ...defaultViewConfig, preRenderId: 'test' });
            searchEmbed.preRender();
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload, mockPort);
            });
            const preRenderWrapper = document.getElementById('tsEmbed-pre-render-wrapper-test');
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(mockPort.postMessage).not.toHaveBeenCalled();
                expect(preRenderWrapper.innerHTML).toContain('Not logged in');
            });
            jest.spyOn(authService, 'verifyTokenService').mockClear();
        });
        test('should show login failure message if update token failed', async () => {
            const a = jest.spyOn(authService, 'verifyTokenService');
            a.mockResolvedValue(true);
            // authVerifyMock.mockResolvedValue(true);
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.AuthExpire,
                data: {},
            };
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            jest.spyOn(baseInstance, 'notifyAuthFailure');
            searchEmbed.render();
            const mockPort = {
                postMessage: jest.fn(),
            };
            const loggerSpy = jest.spyOn(logger_1.logger, 'error').mockImplementation(() => { });
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect((0, test_utils_1.getRootEl)().innerHTML).toContain('Not logged in');
                expect(baseInstance.notifyAuthFailure).toHaveBeenCalledWith(authInstance.AuthFailureType.EXPIRY);
                expect(loggerSpy).toHaveBeenCalledTimes(1);
            });
            jest.spyOn(authService, 'verifyTokenService').mockClear();
            jest.spyOn(baseInstance, 'notifyAuthFailure').mockClear();
        });
        test('should show login failure message if update token failed prerender', async () => {
            const a = jest.spyOn(authService, 'verifyTokenService');
            a.mockResolvedValue(true);
            // authVerifyMock.mockResolvedValue(true);
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.AuthExpire,
                data: {},
            };
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), { ...defaultViewConfig, preRenderId: 'test' });
            jest.spyOn(baseInstance, 'notifyAuthFailure');
            searchEmbed.preRender();
            const loggerSpy = jest.spyOn(logger_1.logger, 'error').mockImplementation(() => { });
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload, mockPort);
            });
            const preRenderWrapper = document.getElementById('tsEmbed-pre-render-wrapper-test');
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(preRenderWrapper.innerHTML).toContain('Not logged in');
                expect(baseInstance.notifyAuthFailure).toHaveBeenCalledWith(authInstance.AuthFailureType.EXPIRY);
                expect(loggerSpy).toHaveBeenCalledTimes(1);
            });
            jest.spyOn(authService, 'verifyTokenService').mockClear();
            jest.spyOn(baseInstance, 'notifyAuthFailure').mockClear();
        });
    });
    xdescribe('AuthExpire embedEvent in TrustedAuthToken authType', () => {
        test('AutoLogin true scenario', async () => {
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                customizations: customisations,
                authType: index_1.AuthType.TrustedAuthToken,
                username: 'tsadmin',
                getAuthToken: () => Promise.resolve('test_auth_token3'),
                autoLogin: true,
            });
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.AuthExpire,
                data: {},
            };
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            jest.spyOn(baseInstance, 'notifyAuthFailure');
            jest.spyOn(baseInstance, 'handleAuth');
            searchEmbed.render();
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(baseInstance.notifyAuthFailure).toHaveBeenCalledWith(authInstance.AuthFailureType.EXPIRY);
                expect(baseInstance.handleAuth).toHaveBeenCalled();
            });
        });
        test('AutoLogin false scenario', async () => {
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                customizations: customisations,
                authType: index_1.AuthType.TrustedAuthToken,
                username: 'tsadmin',
                getAuthToken: () => Promise.resolve('test_auth_token4'),
            });
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.AuthExpire,
                data: {},
            };
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            jest.spyOn(baseInstance, 'notifyAuthFailure');
            jest.spyOn(baseInstance, 'handleAuth');
            searchEmbed.render();
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(baseInstance.notifyAuthFailure).toHaveBeenCalledWith(authInstance.AuthFailureType.EXPIRY);
                expect(baseInstance.handleAuth).not.toHaveBeenCalled();
            });
        });
    });
    describe('when thoughtSpotHost have value and authPromise return response true/false', () => {
        beforeAll(() => {
            (0, index_1.init)({
                thoughtSpotHost,
                authType: index_1.AuthType.None,
                loginFailedMessage: 'Failed to Login',
            });
        });
        const setup = async (isLoggedIn = false) => {
            jest.spyOn(window, 'addEventListener').mockImplementationOnce((event, handler, options) => {
                handler({
                    data: { type: 'xyz' },
                    ports: [3000],
                    source: null,
                });
            });
            const iFrame = document.createElement('div');
            jest.spyOn(baseInstance, 'getAuthPromise').mockResolvedValueOnce(isLoggedIn);
            const tsEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), {});
            iFrame.contentWindow = null;
            tsEmbed.on(index_1.EmbedEvent.CustomAction, jest.fn());
            jest.spyOn(iFrame, 'addEventListener').mockImplementationOnce((event, handler, options) => {
                handler({});
            });
            jest.spyOn(document, 'createElement').mockReturnValueOnce(iFrame);
            await tsEmbed.render();
        };
        test('mixpanel should call with VISUAL_SDK_RENDER_COMPLETE', async () => {
            await setup(true);
            expect(mockMixPanelEvent).toHaveBeenCalledWith(mixpanel_service_1.MIXPANEL_EVENT.VISUAL_SDK_RENDER_START);
            expect(mockMixPanelEvent).toHaveBeenCalledWith(mixpanel_service_1.MIXPANEL_EVENT.VISUAL_SDK_RENDER_COMPLETE, expect.objectContaining({
                elWidth: 0,
                elHeight: 0,
            }));
        });
        test('Should remove prefetch iframe', async () => {
            await setup(true);
            const prefetchIframe = document.querySelectorAll('.prefetchIframe');
            expect(prefetchIframe.length).toBe(0);
        });
        test('Should render failure when login fails', async () => {
            await setup(false);
            expect((0, test_utils_1.getRootEl)().innerHTML).toContain('Failed to Login');
        });
    });
    describe('Trigger infoSuccess event on iframe load', () => {
        beforeAll(() => {
            jest.clearAllMocks();
            (0, index_1.init)({
                thoughtSpotHost,
                authType: index_1.AuthType.None,
                loginFailedMessage: 'Failed to Login',
            });
        });
        const setup = async (isLoggedIn = false, overrideOrgId = undefined) => {
            jest.spyOn(window, 'addEventListener').mockImplementationOnce((event, handler, options) => {
                handler({
                    data: { type: 'xyz' },
                    ports: [3000],
                    source: null,
                });
            });
            mockProcessTrigger.mockResolvedValueOnce({ session: 'test' });
            // resetCachedPreauthInfo();
            let mockGetPreauthInfo = null;
            if (overrideOrgId) {
                mockGetPreauthInfo = jest.spyOn(sessionInfoService, 'getPreauthInfo').mockImplementation(jest.fn());
            }
            const mockPreauthInfoFetch = jest.spyOn(authService, 'fetchPreauthInfoService').mockResolvedValueOnce({
                ok: true,
                headers: new Headers({ 'content-type': 'application/json' }),
                json: async () => ({
                    info: {
                        configInfo: {
                            mixpanelConfig: {
                                devSdkKey: 'devSdkKey',
                            },
                        },
                        userGUID: 'userGUID',
                    },
                }), // Mock JSON response
            });
            const iFrame = document.createElement('div');
            jest.spyOn(baseInstance, 'getAuthPromise').mockResolvedValueOnce(isLoggedIn);
            const tsEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), {
                overrideOrgId,
            });
            iFrame.contentWindow = {
                postMessage: jest.fn(),
            };
            tsEmbed.on(index_1.EmbedEvent.CustomAction, jest.fn());
            jest.spyOn(iFrame, 'addEventListener').mockImplementationOnce((event, handler, options) => {
                handler({});
            });
            jest.spyOn(document, 'createElement').mockReturnValueOnce(iFrame);
            await tsEmbed.render();
            return {
                mockPreauthInfoFetch,
                mockGetPreauthInfo,
                iFrame,
            };
        };
        test('should call InfoSuccess Event on preauth call success', async () => {
            const { mockPreauthInfoFetch, iFrame, } = await setup(true);
            expect(mockPreauthInfoFetch).toHaveBeenCalledTimes(1);
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(mockProcessTrigger).toHaveBeenCalledWith(iFrame, types_1.HostEvent.InfoSuccess, 'http://tshost', expect.objectContaining({ info: expect.any(Object) }), undefined);
            });
        });
        test('should not call InfoSuccess Event if overrideOrgId is true', async () => {
            const { mockGetPreauthInfo, } = await setup(true, 123);
            expect(mockGetPreauthInfo).toHaveBeenCalledTimes(0);
        });
    });
    describe('Preauth Cache for FullAppEmbed with PrimaryNavBar', () => {
        beforeAll(() => {
            jest.clearAllMocks();
            (0, index_1.init)({
                thoughtSpotHost,
                authType: index_1.AuthType.None,
            });
        });
        afterEach(() => {
            jest.clearAllMocks();
        });
        afterAll(() => {
            jest.clearAllMocks();
        });
        const setupPreauthTest = async (embedType, showPrimaryNavbar, overrideOrgId, disablePreauthCache) => {
            jest.spyOn(window, 'addEventListener').mockImplementationOnce((event, handler, options) => {
                handler({
                    data: { type: 'xyz' },
                    ports: [3000],
                    source: null,
                });
            });
            mockProcessTrigger.mockResolvedValueOnce({ session: 'test' });
            jest.spyOn(baseInstance, 'getAuthPromise').mockResolvedValueOnce(true);
            let mockGetPreauthInfo = null;
            // Determine if preauth cache should be enabled
            const isAppEmbedWithPrimaryNavbar = embedType === 'AppEmbed' && showPrimaryNavbar === true;
            const shouldDisableCache = overrideOrgId || disablePreauthCache || isAppEmbedWithPrimaryNavbar;
            if (shouldDisableCache) {
                mockGetPreauthInfo = jest.spyOn(sessionInfoService, 'getPreauthInfo')
                    .mockImplementation(jest.fn());
            }
            else {
                mockGetPreauthInfo = jest.spyOn(sessionInfoService, 'getPreauthInfo')
                    .mockResolvedValue({ info: { test: 'data' } });
            }
            const mockPreauthInfoFetch = jest.spyOn(authService, 'fetchPreauthInfoService')
                .mockResolvedValueOnce({
                ok: true,
                headers: new Headers({ 'content-type': 'application/json' }),
                json: async () => ({
                    info: { test: 'data' },
                }),
            });
            const viewConfig = {
                frameParams: { width: 1280, height: 720 },
            };
            if (showPrimaryNavbar !== undefined) {
                viewConfig.showPrimaryNavbar = showPrimaryNavbar;
            }
            if (overrideOrgId !== undefined) {
                viewConfig.overrideOrgId = overrideOrgId;
            }
            // Mock getEmbedConfig for disablePreauthCache
            if (disablePreauthCache !== undefined) {
                jest.spyOn(embedConfig, 'getEmbedConfig').mockReturnValueOnce({
                    thoughtSpotHost,
                    authType: index_1.AuthType.None,
                    disablePreauthCache,
                });
            }
            let embed;
            if (embedType === 'AppEmbed') {
                embed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), viewConfig);
            }
            else {
                embed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), viewConfig);
            }
            const iFrame = document.createElement('div');
            iFrame.contentWindow = {
                postMessage: jest.fn(),
            };
            jest.spyOn(iFrame, 'addEventListener').mockImplementationOnce((event, handler, options) => {
                handler({});
            });
            jest.spyOn(document, 'createElement').mockReturnValueOnce(iFrame);
            await embed.render();
            return {
                embed,
                mockGetPreauthInfo,
                mockPreauthInfoFetch,
                iFrame,
            };
        };
        test('should disable preauth cache for FullAppEmbed with showPrimaryNavbar = true (default)', async () => {
            const { mockGetPreauthInfo } = await setupPreauthTest('AppEmbed', true);
            // Wait for any async operations
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(mockGetPreauthInfo).toHaveBeenCalledTimes(0);
            });
        });
        test('should enable preauth cache for FullAppEmbed with showPrimaryNavbar = undefined (no longer defaults to true)', async () => {
            const { mockGetPreauthInfo } = await setupPreauthTest('AppEmbed', undefined);
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(mockGetPreauthInfo).toHaveBeenCalledTimes(1);
                expect(mockProcessTrigger).toHaveBeenCalledWith(expect.any(Object), types_1.HostEvent.InfoSuccess, 'http://tshost', expect.objectContaining({ info: expect.any(Object) }), undefined);
            });
        });
        test('should enable preauth cache for FullAppEmbed with showPrimaryNavbar = false', async () => {
            const { mockGetPreauthInfo } = await setupPreauthTest('AppEmbed', false);
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(mockGetPreauthInfo).toHaveBeenCalledTimes(1);
                expect(mockProcessTrigger).toHaveBeenCalledWith(expect.any(Object), types_1.HostEvent.InfoSuccess, 'http://tshost', expect.objectContaining({ info: expect.any(Object) }), undefined);
            });
        });
        test('should enable preauth cache for SearchEmbed regardless of showPrimaryNavbar', async () => {
            const { mockGetPreauthInfo } = await setupPreauthTest('SearchEmbed', true);
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(mockGetPreauthInfo).toHaveBeenCalledTimes(1);
                expect(mockProcessTrigger).toHaveBeenCalledWith(expect.any(Object), types_1.HostEvent.InfoSuccess, 'http://tshost', expect.objectContaining({ info: expect.any(Object) }), undefined);
            });
        });
        test('should enable preauth cache for SearchEmbed (verifies fix for embed type regression)', async () => {
            const { mockGetPreauthInfo } = await setupPreauthTest('SearchEmbed', false);
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(mockGetPreauthInfo).toHaveBeenCalledTimes(1);
                expect(mockProcessTrigger).toHaveBeenCalledWith(expect.any(Object), types_1.HostEvent.InfoSuccess, 'http://tshost', expect.objectContaining({ info: expect.any(Object) }), undefined);
            });
        });
        test('should disable preauth cache for FullAppEmbed with overrideOrgId (combined condition)', async () => {
            const { mockGetPreauthInfo } = await setupPreauthTest('AppEmbed', false, 123);
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(mockGetPreauthInfo).toHaveBeenCalledTimes(0);
            });
        });
        test('should disable preauth cache for FullAppEmbed with disablePreauthCache = true', async () => {
            const { mockGetPreauthInfo } = await setupPreauthTest('AppEmbed', false, undefined, true);
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(mockGetPreauthInfo).toHaveBeenCalledTimes(0);
            });
        });
    });
    describe('isFullAppEmbedWithVisiblePrimaryNavbar helper method', () => {
        beforeAll(() => {
            (0, index_1.init)({
                thoughtSpotHost,
                authType: index_1.AuthType.None,
            });
        });
        afterEach(() => {
            jest.clearAllMocks();
        });
        test('should return true for AppEmbed with showPrimaryNavbar = true', () => {
            const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), { showPrimaryNavbar: true });
            expect(appEmbed['isFullAppEmbedWithVisiblePrimaryNavbar']()).toBe(true);
        });
        test('should return false for AppEmbed with showPrimaryNavbar = undefined (no longer defaults to true)', () => {
            const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {});
            expect(appEmbed['isFullAppEmbedWithVisiblePrimaryNavbar']()).toBe(false);
        });
        test('should return false for AppEmbed with showPrimaryNavbar = false', () => {
            const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), { showPrimaryNavbar: false });
            expect(appEmbed['isFullAppEmbedWithVisiblePrimaryNavbar']()).toBe(false);
        });
        test('should return false for SearchEmbed (not FullAppEmbed)', () => {
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), {});
            expect(searchEmbed['isFullAppEmbedWithVisiblePrimaryNavbar']()).toBe(false);
        });
        test('should return false for LiveboardEmbed (not FullAppEmbed)', () => {
            const liveboardEmbed = new index_1.LiveboardEmbed((0, test_utils_1.getRootEl)(), { liveboardId: 'test-id' });
            expect(liveboardEmbed['isFullAppEmbedWithVisiblePrimaryNavbar']()).toBe(false);
        });
    });
    describe('when thoughtSpotHost have value and authPromise return error', () => {
        beforeAll(() => {
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.None,
            });
        });
        beforeEach(async () => {
            jest.spyOn(baseInstance, 'getAuthPromise').mockRejectedValueOnce(false);
            const tsEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), {});
            const iFrame = document.createElement('div');
            iFrame.contentWindow = null;
            jest.spyOn(document, 'createElement').mockReturnValueOnce(iFrame);
            jest.spyOn(logger_1.logger, 'error');
            await tsEmbed.render();
        });
        test('mixpanel should call with VISUAL_SDK_RENDER_FAILED', () => {
            expect(mockMixPanelEvent).toHaveBeenCalledWith(mixpanel_service_1.MIXPANEL_EVENT.VISUAL_SDK_RENDER_START);
            expect(mockMixPanelEvent).toHaveBeenCalledWith(mixpanel_service_1.MIXPANEL_EVENT.VISUAL_SDK_RENDER_FAILED, {
                error: 'false',
            });
        });
    });
    describe('when visible actions are set', () => {
        test('should throw error when there are both visible and hidden actions - pinboard', async () => {
            jest.spyOn(logger_1.logger, 'error');
            const pinboardEmbed = new index_1.PinboardEmbed((0, test_utils_1.getRootEl)(), {
                hiddenActions: [types_1.Action.DownloadAsCsv],
                visibleActions: [types_1.Action.DownloadAsCsv],
                ...defaultViewConfig,
                pinboardId,
            });
            await pinboardEmbed.render();
            expect(pinboardEmbed['isError']).toBe(true);
            expect(logger_1.logger.error).toHaveBeenCalledWith({
                errorType: types_1.ErrorDetailsTypes.VALIDATION_ERROR,
                message: errors_1.ERROR_MESSAGE.CONFLICTING_ACTIONS_CONFIG,
                code: types_1.EmbedErrorCodes.CONFLICTING_ACTIONS_CONFIG,
                error: errors_1.ERROR_MESSAGE.CONFLICTING_ACTIONS_CONFIG,
            });
        });
        test('should not throw error when there are only visible or hidden actions - pinboard', async () => {
            const pinboardEmbed = new index_1.PinboardEmbed((0, test_utils_1.getRootEl)(), {
                hiddenActions: [types_1.Action.DownloadAsCsv],
                ...defaultViewConfig,
                pinboardId,
            });
            pinboardEmbed.render();
            expect(pinboardEmbed['isError']).toBe(false);
        });
        /**
         *
         * @param hiddenActions
         * @param visibleActions
         */
        async function testActionsForLiveboards(hiddenActions, visibleActions) {
            jest.spyOn(logger_1.logger, 'error');
            const liveboardEmbed = new index_1.LiveboardEmbed((0, test_utils_1.getRootEl)(), {
                hiddenActions,
                visibleActions,
                ...defaultViewConfig,
                liveboardId,
            });
            await liveboardEmbed.render();
            expect(liveboardEmbed['isError']).toBe(true);
            expect(logger_1.logger.error).toHaveBeenCalledWith({
                errorType: types_1.ErrorDetailsTypes.VALIDATION_ERROR,
                message: errors_1.ERROR_MESSAGE.CONFLICTING_ACTIONS_CONFIG,
                code: types_1.EmbedErrorCodes.CONFLICTING_ACTIONS_CONFIG,
                error: errors_1.ERROR_MESSAGE.CONFLICTING_ACTIONS_CONFIG,
            });
        }
        test('should throw error when there are both visible and hidden action arrays', async () => {
            await testActionsForLiveboards([types_1.Action.DownloadAsCsv], [types_1.Action.DownloadAsCsv]);
        });
        test('should throw error when there are both visible and hidden actions arrays as empty', async () => {
            await testActionsForLiveboards([], []);
        });
        test('should throw error when there are both visible and hidden actions - one of them is an empty array', async () => {
            await testActionsForLiveboards([], [types_1.Action.DownloadAsCsv]);
        });
        test('should not throw error when there are only visible or hidden actions', async () => {
            const liveboardEmbed = new index_1.LiveboardEmbed((0, test_utils_1.getRootEl)(), {
                hiddenActions: [types_1.Action.DownloadAsCsv],
                ...defaultViewConfig,
                liveboardId,
            });
            liveboardEmbed.render();
            expect(liveboardEmbed['isError']).toBe(false);
        });
        test('should not throw error when there are only visible or hidden actions', async () => {
            const liveboardEmbed = new index_1.LiveboardEmbed((0, test_utils_1.getRootEl)(), {
                visibleActions: [types_1.Action.DownloadAsCsv],
                ...defaultViewConfig,
                liveboardId,
            });
            liveboardEmbed.render();
            expect(liveboardEmbed['isError']).toBe(false);
        });
    });
    describe('when visible Tabs are set', () => {
        test('should throw error when there are both visible and hidden Tabs - pinboard', async () => {
            jest.spyOn(logger_1.logger, 'error');
            const pinboardEmbed = new index_1.PinboardEmbed((0, test_utils_1.getRootEl)(), {
                visibleTabs: [tabId1],
                hiddenTabs: [tabId2],
                ...defaultViewConfig,
                pinboardId,
            });
            await pinboardEmbed.render();
            expect(pinboardEmbed['isError']).toBe(true);
            expect(logger_1.logger.error).toHaveBeenCalledWith({
                errorType: types_1.ErrorDetailsTypes.VALIDATION_ERROR,
                message: errors_1.ERROR_MESSAGE.CONFLICTING_TABS_CONFIG,
                code: types_1.EmbedErrorCodes.CONFLICTING_TABS_CONFIG,
                error: errors_1.ERROR_MESSAGE.CONFLICTING_TABS_CONFIG,
            });
        });
        test('should not throw error when there are only visible or hidden Tabs - pinboard', async () => {
            const pinboardEmbed = new index_1.PinboardEmbed((0, test_utils_1.getRootEl)(), {
                hiddenTabs: [tabId1],
                ...defaultViewConfig,
                pinboardId,
            });
            pinboardEmbed.render();
            expect(pinboardEmbed['isError']).toBe(false);
        });
        /**
         *
         * @param hiddenTabs
         * @param visibleTabs
         */
        async function testTabsForLiveboards(hiddenTabs, visibleTabs) {
            jest.spyOn(logger_1.logger, 'error');
            const liveboardEmbed = new index_1.LiveboardEmbed((0, test_utils_1.getRootEl)(), {
                hiddenTabs,
                visibleTabs,
                ...defaultViewConfig,
                liveboardId,
            });
            await liveboardEmbed.render();
            expect(liveboardEmbed['isError']).toBe(true);
            expect(logger_1.logger.error).toHaveBeenCalledWith({
                errorType: types_1.ErrorDetailsTypes.VALIDATION_ERROR,
                message: errors_1.ERROR_MESSAGE.CONFLICTING_TABS_CONFIG,
                code: types_1.EmbedErrorCodes.CONFLICTING_TABS_CONFIG,
                error: errors_1.ERROR_MESSAGE.CONFLICTING_TABS_CONFIG,
            });
        }
        test('should throw error when there are both visible and hidden Tab arrays', async () => {
            await testTabsForLiveboards([tabId1], [tabId2]);
        });
        test('should throw error when there are both visible and hidden Tab arrays as empty', async () => {
            await testTabsForLiveboards([], []);
        });
        test('should throw error when there are both visible and hidden Tabs - one of them is an empty array', async () => {
            await testTabsForLiveboards([], [tabId2]);
        });
        test('should not throw error when there are only visible or hidden Tab', async () => {
            const liveboardEmbed = new index_1.LiveboardEmbed((0, test_utils_1.getRootEl)(), {
                hiddenTabs: [tabId2],
                ...defaultViewConfig,
                liveboardId,
            });
            liveboardEmbed.render();
            expect(liveboardEmbed['isError']).toBe(false);
        });
        test('should not throw error when there are only visible or hidden Tabs', async () => {
            const liveboardEmbed = new index_1.LiveboardEmbed((0, test_utils_1.getRootEl)(), {
                visibleTabs: [tabId1],
                ...defaultViewConfig,
                liveboardId,
            });
            liveboardEmbed.render();
            expect(liveboardEmbed['isError']).toBe(false);
        });
    });
    describe('when thoughtSpotHost is empty', () => {
        beforeAll(() => {
            jest.spyOn(config, 'getThoughtSpotHost').mockImplementation(() => '');
            (0, index_1.init)({
                thoughtSpotHost: '',
                authType: index_1.AuthType.None,
            });
        });
        test('Error should be true', async () => {
            jest.spyOn(logger_1.logger, 'error');
            const tsEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), {});
            await tsEmbed.render();
            expect(tsEmbed['isError']).toBe(true);
            expect(logger_1.logger.error).toHaveBeenCalledWith({
                errorType: types_1.ErrorDetailsTypes.VALIDATION_ERROR,
                message: errors_1.ERROR_MESSAGE.INIT_SDK_REQUIRED,
                code: types_1.EmbedErrorCodes.INIT_ERROR,
                error: errors_1.ERROR_MESSAGE.INIT_SDK_REQUIRED,
            });
        });
    });
    describe('V1Embed ', () => {
        beforeEach(() => {
            jest.spyOn(config, 'getThoughtSpotHost').mockImplementation(() => 'http://tshost');
        });
        test('when isRendered is true than isError will be true', async () => {
            jest.spyOn(logger_1.logger, 'warn');
            const viEmbedIns = new tsEmbedInstance.V1Embed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            expect(viEmbedIns['isError']).toBe(false);
            await viEmbedIns.render();
            viEmbedIns.on(index_1.EmbedEvent.CustomAction, jest.fn()).render();
            expect(logger_1.logger.warn).toHaveBeenCalledWith('Please register event handlers before calling render');
        });
        test('Generates the correct url for V1Embed when V2 shell is enabled', async () => {
            const v1Embed = new index_1.LiveboardEmbed((0, test_utils_1.getRootEl)(), {
                ...defaultViewConfig,
                liveboardId: '123',
                enableV2Shell_experimental: true,
            });
            await v1Embed.render();
            await (0, test_utils_1.executeAfterWait)(() => {
                expect((0, test_utils_1.getIFrameSrc)()).toContain('/v2/?');
            });
        });
    });
    describe('Navigate to Page API', () => {
        const path = 'viz/e0836cad-4fdf-42d4-bd97-567a6b2a6058';
        beforeEach(() => {
            jest.spyOn(config, 'getThoughtSpotHost').mockImplementation(() => 'http://tshost');
        });
        test('when app is PinboardEmbed after navigateToPage function call, new path should be set to iframe', async () => {
            const pinboardEmbed = new index_1.PinboardEmbed((0, test_utils_1.getRootEl)(), {
                pinboardId: 'e0836cad-4fdf-42d4-bd97-567a6b2a6058',
            });
            await pinboardEmbed.render();
            // pinboardEmbed.navigateToPage(path);
            (0, test_utils_1.expectUrlMatchesWithParams)((0, test_utils_1.getIFrameSrc)(), `http://${thoughtSpotHost}/?embedApp=true&${test_utils_1.defaultParamsForPinboardEmbed}&isLiveboardEmbed=true${defaultParamsPost}#/embed/${path}`);
        });
        test('when app is AppEmbed after navigateToPage function call, new path should be set to iframe', async () => {
            const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                frameParams: {
                    width: '100%',
                    height: '100%',
                },
            });
            await appEmbed.render();
            appEmbed.navigateToPage(path, false);
            (0, test_utils_1.expectUrlMatchesWithParams)((0, test_utils_1.getIFrameSrc)(), `http://${thoughtSpotHost}/?embedApp=true&primaryNavHidden=true&profileAndHelpInNavBarHidden=false&${test_utils_1.defaultParamsForPinboardEmbed}${defaultParamsPost}#/${path}`);
        });
        test('navigateToPage function use before render', async () => {
            jest.spyOn(logger_1.logger, 'log');
            const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                frameParams: {
                    width: '100%',
                    height: '100%',
                },
            });
            appEmbed.navigateToPage(path, false);
            await appEmbed.render();
            expect(logger_1.logger.log).toHaveBeenCalledWith('Please call render before invoking this method');
        });
    });
    describe('Navigate to Page API - Pinboard', () => {
        const path = 'pinboard/e0836cad-4fdf-42d4-bd97-567a6b2a6058';
        beforeEach(() => {
            jest.spyOn(config, 'getThoughtSpotHost').mockImplementation(() => 'http://tshost');
        });
        test('when app is AppEmbed after navigateToPage function call, new path should be set to iframe', async () => {
            const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                frameParams: {
                    width: '100%',
                    height: '100%',
                },
            });
            await appEmbed.render();
            appEmbed.navigateToPage(path, false);
            (0, test_utils_1.expectUrlMatchesWithParams)((0, test_utils_1.getIFrameSrc)(), `http://${thoughtSpotHost}/?embedApp=true&primaryNavHidden=true&profileAndHelpInNavBarHidden=false&${test_utils_1.defaultParamsForPinboardEmbed}${defaultParamsPost}#/${path}`);
        });
    });
    describe('get Encoded query param string', () => {
        beforeAll(() => {
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.None,
                shouldEncodeUrlQueryParams: true,
            });
        });
        afterAll(() => {
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.None,
                shouldEncodeUrlQueryParams: false,
            });
        });
        it('should return the correct encoded query params string', async () => {
            const tsEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), {
                frameParams: {
                    width: '100%',
                    height: '100%',
                },
            });
            tsEmbed.render();
            await (0, test_utils_1.waitFor)(() => !!(0, test_utils_1.getIFrameEl)()).then(() => {
                expect((0, test_utils_1.getIFrameSrc)()).toContain('?base64UrlEncodedFlags');
            });
        });
        it('should return the correct encoded query params string when app is embeded', async () => {
            const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                frameParams: {
                    width: '100%',
                    height: '100%',
                },
            });
            appEmbed.render();
            await (0, test_utils_1.waitFor)(() => !!(0, test_utils_1.getIFrameEl)()).then(() => {
                expect((0, test_utils_1.getIFrameSrc)()).toContain('?base64UrlEncodedFlags');
            });
        });
    });
    describe('Iframe flags', () => {
        beforeEach(() => {
            jest.spyOn(config, 'getThoughtSpotHost').mockImplementation(() => 'http://tshost');
        });
        test('Set Frame params to the iframe as attributes', async () => {
            const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                frameParams: {
                    width: '100%',
                    height: '100%',
                    allowtransparency: true,
                },
            });
            await appEmbed.render();
            const iframe = (0, test_utils_1.getIFrameEl)();
            expect(iframe.getAttribute('allowtransparency')).toBe('true');
        });
        it('should set the additional flags correctly on the iframe src', async () => {
            const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                frameParams: {
                    width: '100%',
                    height: '100%',
                },
                additionalFlags: {
                    foo: 'bar',
                    baz: 1,
                    bool: true,
                },
            });
            await appEmbed.render();
            (0, test_utils_1.expectUrlMatchesWithParams)((0, test_utils_1.getIFrameSrc)(), `http://${thoughtSpotHost}/?embedApp=true&primaryNavHidden=true&profileAndHelpInNavBarHidden=false&${test_utils_1.defaultParamsForPinboardEmbed}`
                + `&foo=bar&baz=1&bool=true${defaultParamsPost}#/home`);
        });
        it('should set the additional flags correctly on the iframe src from init and view config', async () => {
            (0, index_1.init)({
                thoughtSpotHost: 'http://tshost',
                authType: index_1.AuthType.None,
                additionalFlags: {
                    foo: 'bar1',
                    foo2: 'bar2',
                    foo3: false,
                },
            });
            const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                frameParams: {
                    width: '100%',
                    height: '100%',
                },
                additionalFlags: {
                    foo: 'bar',
                    baz: 1,
                    bool: true,
                },
            });
            await appEmbed.render();
            (0, test_utils_1.expectUrlMatchesWithParams)((0, test_utils_1.getIFrameSrc)(), `http://${thoughtSpotHost}/?embedApp=true&primaryNavHidden=true&profileAndHelpInNavBarHidden=false&${test_utils_1.defaultParamsForPinboardEmbed}`
                + `&foo=bar&foo2=bar2&foo3=false&baz=1&bool=true${defaultParamsPost}#/home`);
        });
        it('Sets the showAlerts param', async () => {
            const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                frameParams: {
                    width: '100%',
                    height: '100%',
                },
                showAlerts: true,
            });
            await appEmbed.render();
            (0, test_utils_1.expectUrlMatchesWithParams)((0, test_utils_1.getIFrameSrc)(), `http://${thoughtSpotHost}/?embedApp=true&primaryNavHidden=true&profileAndHelpInNavBarHidden=false&${test_utils_1.defaultParamsForPinboardEmbed}`
                + `&showAlerts=true${defaultParamsPost}#/home`);
        });
        it('Sets the locale param', async () => {
            const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                frameParams: {
                    width: '100%',
                    height: '100%',
                },
                locale: 'ja-JP',
            });
            await appEmbed.render();
            (0, test_utils_1.expectUrlMatchesWithParams)((0, test_utils_1.getIFrameSrc)(), `http://${thoughtSpotHost}/?embedApp=true&primaryNavHidden=true&profileAndHelpInNavBarHidden=false&${test_utils_1.defaultParamsForPinboardEmbed}`
                + `&locale=ja-JP${defaultParamsPost}#/home`);
        });
        it('Sets the iconSprite url', async () => {
            const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                frameParams: {
                    width: '100%',
                    height: '100%',
                },
                customizations: {
                    iconSpriteUrl: 'https://iconSprite.com',
                },
            });
            await appEmbed.render();
            (0, test_utils_1.expectUrlMatchesWithParams)((0, test_utils_1.getIFrameSrc)(), `http://${thoughtSpotHost}/?embedApp=true&primaryNavHidden=true&profileAndHelpInNavBarHidden=false&${test_utils_1.defaultParamsForPinboardEmbed}`
                + `&iconSprite=iconSprite.com${defaultParamsPost}#/home`);
        });
        it('inserts as sibling of root node if configured', async () => {
            const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                frameParams: {
                    width: '100%',
                    height: '100%',
                },
                insertAsSibling: true,
            });
            await appEmbed.render();
            expect((0, test_utils_1.getRootEl)().nextSibling).toBe((0, test_utils_1.getIFrameEl)());
        });
        it('Should remove existing embed when rerendering', async () => {
            const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                frameParams: {
                    width: '100%',
                    height: '100%',
                },
                insertAsSibling: true,
            });
            await appEmbed.render();
            expect((0, test_utils_1.getRootEl)().nextSibling).toBe((0, test_utils_1.getIFrameEl)());
            await appEmbed.render();
            expect((0, test_utils_1.getRootEl)().nextSibling.nextSibling).not.toBe((0, test_utils_1.getIFrameEl)());
        });
        it('Should set the pendo tracking key when specified', async () => {
            jest.spyOn(baseInstance, 'getAuthPromise').mockResolvedValue(true);
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.None,
                pendoTrackingKey: '1234',
            });
            const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                frameParams: {
                    width: '100%',
                    height: '100%',
                },
            });
            await appEmbed.render();
            (0, test_utils_1.expectUrlMatchesWithParams)((0, test_utils_1.getIFrameSrc)(), `http://${thoughtSpotHost}/?embedApp=true&primaryNavHidden=true&profileAndHelpInNavBarHidden=false&additionalPendoKey=1234${defaultParamsPost}#/home`);
        });
        xit('Sets the forceSAMLAutoRedirect param', async () => {
            jest.spyOn(baseInstance, 'getAuthPromise').mockResolvedValue(true);
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.EmbeddedSSO,
            });
            const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                frameParams: {
                    width: '100%',
                    height: '100%',
                },
            });
            appEmbed.render();
            expect((0, test_utils_1.getIFrameSrc)()).toContain('authType=EmbeddedSSO');
            expect((0, test_utils_1.getIFrameSrc)()).toContain('forceSAMLAutoRedirect=true');
        });
        it('Should set the override locale for number/date and currency format', async () => {
            jest.spyOn(baseInstance, 'getAuthPromise').mockResolvedValue(true);
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.None,
                numberFormatLocale: 'en-US',
                dateFormatLocale: 'en-IN',
                currencyFormat: 'USD',
            });
            const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                frameParams: {
                    width: '100%',
                    height: '100%',
                },
            });
            await appEmbed.render();
            (0, test_utils_1.expectUrlMatchesWithParams)((0, test_utils_1.getIFrameSrc)(), `http://${thoughtSpotHost}/?embedApp=true&primaryNavHidden=true&profileAndHelpInNavBarHidden=false&numberFormatLocale=en-US&dateFormatLocale=en-IN&currencyFormat=USD${defaultParamsPost}#/home`);
        });
        it('Sets the overrideOrgId param', async () => {
            const overrideOrgId = 142536;
            const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                frameParams: {
                    width: '100%',
                    height: '100%',
                },
                overrideOrgId,
            });
            await appEmbed.render();
            (0, test_utils_1.expectUrlToHaveParamsWithValues)((0, test_utils_1.getIFrameSrc)(), {
                orgId: overrideOrgId,
            });
        });
        it('Should not add contextMenuEnabledOnWhichClick flag to the iframe src when it is not passed', async () => {
            const liveboardEmbed = new index_1.LiveboardEmbed((0, test_utils_1.getRootEl)(), {
                ...defaultViewConfig,
                liveboardId,
            });
            liveboardEmbed.render();
            await (0, test_utils_1.executeAfterWait)(() => {
                (0, test_utils_1.expectUrlMatchesWithParams)((0, test_utils_1.getIFrameSrc)(), `http://${thoughtSpotHost}/?embedApp=true${exports.defaultParams}#/embed/viz/${liveboardId}`);
            });
            const defaultConfig = {
                disableWorksheetChange: false,
                hideWorksheetSelector: false,
                hideSageAnswerHeader: false,
                hideAutocompleteSuggestions: false,
                hideSampleQuestions: false,
                isProductTour: false,
                dataPanelV2: false,
            };
            const sageEmbed = new index_1.SageEmbed((0, test_utils_1.getRootEl)(), {
                ...defaultConfig,
            });
            sageEmbed.render();
            await (0, test_utils_1.executeAfterWait)(() => {
                (0, test_utils_1.expectUrlMatch)((0, test_utils_1.getIFrameSrc)(), `http://${thoughtSpotHost}/?embedApp=true&enableDataPanelV2=false&isSageEmbed=true&disableWorksheetChange=false&hideWorksheetSelector=false&hideEurekaSuggestions=false&isProductTour=false&hideSageAnswerHeader=false&hideAction=%5B%22reportError%22%5D#/embed/eureka`);
            });
        });
        it('Should add contextMenuEnabledOnWhichClick flag to the iframe with left value', async () => {
            const liveboardEmbed = new index_1.LiveboardEmbed((0, test_utils_1.getRootEl)(), {
                ...defaultViewConfig,
                liveboardId,
                contextMenuTrigger: types_1.ContextMenuTriggerOptions.LEFT_CLICK,
            });
            liveboardEmbed.render();
            await (0, test_utils_1.executeAfterWait)(() => {
                (0, test_utils_1.expectUrlMatchesWithParams)((0, test_utils_1.getIFrameSrc)(), `http://${thoughtSpotHost}/?embedApp=true${exports.defaultParams}&contextMenuEnabledOnWhichClick=left#/embed/viz/${liveboardId}`);
            });
            const defaultConfig = {
                disableWorksheetChange: false,
                hideWorksheetSelector: false,
                hideSageAnswerHeader: false,
                hideAutocompleteSuggestions: false,
                hideSampleQuestions: false,
                isProductTour: false,
                dataPanelV2: false,
            };
            const sageEmbed = new index_1.SageEmbed((0, test_utils_1.getRootEl)(), {
                ...defaultConfig,
                contextMenuTrigger: types_1.ContextMenuTriggerOptions.LEFT_CLICK,
            });
            sageEmbed.render();
            await (0, test_utils_1.executeAfterWait)(() => {
                (0, test_utils_1.expectUrlMatch)((0, test_utils_1.getIFrameSrc)(), `http://${thoughtSpotHost}/?embedApp=true&enableDataPanelV2=false&contextMenuEnabledOnWhichClick=left&isSageEmbed=true&disableWorksheetChange=false&hideWorksheetSelector=false&hideEurekaSuggestions=false&isProductTour=false&hideSageAnswerHeader=false&hideAction=%5B%22reportError%22%5D#/embed/eureka`);
            });
        });
        it('Should add contextMenuEnabledOnWhichClick flag to the iframe with right value', async () => {
            const liveboardEmbed = new index_1.LiveboardEmbed((0, test_utils_1.getRootEl)(), {
                ...defaultViewConfig,
                liveboardId,
                contextMenuTrigger: types_1.ContextMenuTriggerOptions.RIGHT_CLICK,
            });
            liveboardEmbed.render();
            await (0, test_utils_1.executeAfterWait)(() => {
                (0, test_utils_1.expectUrlMatchesWithParams)((0, test_utils_1.getIFrameSrc)(), `http://${thoughtSpotHost}/?embedApp=true${exports.defaultParams}&contextMenuEnabledOnWhichClick=right#/embed/viz/${liveboardId}`);
            });
            const defaultConfig = {
                disableWorksheetChange: false,
                hideWorksheetSelector: false,
                hideSageAnswerHeader: false,
                hideAutocompleteSuggestions: false,
                hideSampleQuestions: false,
                isProductTour: false,
                dataPanelV2: false,
            };
            const sageEmbed = new index_1.SageEmbed((0, test_utils_1.getRootEl)(), {
                ...defaultConfig,
                contextMenuTrigger: types_1.ContextMenuTriggerOptions.RIGHT_CLICK,
            });
            sageEmbed.render();
            await (0, test_utils_1.executeAfterWait)(() => {
                (0, test_utils_1.expectUrlMatch)((0, test_utils_1.getIFrameSrc)(), `http://${thoughtSpotHost}/?embedApp=true&enableDataPanelV2=false&contextMenuEnabledOnWhichClick=right&isSageEmbed=true&disableWorksheetChange=false&hideWorksheetSelector=false&hideEurekaSuggestions=false&isProductTour=false&hideSageAnswerHeader=false&hideAction=%5B%22reportError%22%5D#/embed/eureka`);
            });
        });
        it('Should add contextMenuEnabledOnWhichClick flag to the iframe with both value', async () => {
            const liveboardEmbed = new index_1.LiveboardEmbed((0, test_utils_1.getRootEl)(), {
                ...defaultViewConfig,
                liveboardId,
                contextMenuTrigger: types_1.ContextMenuTriggerOptions.BOTH_CLICKS,
            });
            liveboardEmbed.render();
            await (0, test_utils_1.executeAfterWait)(() => {
                (0, test_utils_1.expectUrlMatchesWithParams)((0, test_utils_1.getIFrameSrc)(), `http://${thoughtSpotHost}/?embedApp=true${exports.defaultParams}&contextMenuEnabledOnWhichClick=both#/embed/viz/${liveboardId}`);
            });
            const defaultConfig = {
                disableWorksheetChange: false,
                hideWorksheetSelector: false,
                hideSageAnswerHeader: false,
                hideAutocompleteSuggestions: false,
                hideSampleQuestions: false,
                isProductTour: false,
                dataPanelV2: false,
            };
            const sageEmbed = new index_1.SageEmbed((0, test_utils_1.getRootEl)(), {
                ...defaultConfig,
                contextMenuTrigger: types_1.ContextMenuTriggerOptions.BOTH_CLICKS,
            });
            sageEmbed.render();
            await (0, test_utils_1.executeAfterWait)(() => {
                (0, test_utils_1.expectUrlMatch)((0, test_utils_1.getIFrameSrc)(), `http://${thoughtSpotHost}/?embedApp=true&enableDataPanelV2=false&contextMenuEnabledOnWhichClick=both&isSageEmbed=true&disableWorksheetChange=false&hideWorksheetSelector=false&hideEurekaSuggestions=false&isProductTour=false&hideSageAnswerHeader=false&hideAction=%5B%22reportError%22%5D#/embed/eureka`);
            });
        });
    });
    describe('validate getThoughtSpotPostUrlParams', () => {
        const { location } = window;
        beforeAll(() => {
            delete window.location;
            window.location = {
                assign: jest.fn(),
            };
        });
        beforeEach(() => {
            jest.spyOn(config, 'getThoughtSpotHost').mockImplementation(() => 'http://tshost');
        });
        afterAll(() => {
            window.location = location;
        });
        it('get url params for TS', () => {
            const tsEmbed = new tsEmbedInstance.TsEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            const urlHash = '#/analyze?ts-app=thoughtspot&ts-id=123&title=embed-sdk';
            window.location.hash = urlHash;
            const postHashParams = '?ts-app=thoughtspot&ts-id=123';
            expect(tsEmbed.getThoughtSpotPostUrlParams()).toBe(postHashParams);
        });
        it('validate query params and postHash params for TS', () => {
            const tsEmbed = new tsEmbedInstance.TsEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            const urlHash = '#/analyze?ts-app=thoughtspot&ts-id=123&title=embed-sdk';
            window.location.hash = urlHash;
            const urlSearch = '?ts-type=subscribe&search-title=abc';
            window.location.search = urlSearch;
            const postHashParams = '?ts-type=subscribe&ts-app=thoughtspot&ts-id=123';
            expect(tsEmbed.getThoughtSpotPostUrlParams()).toBe(postHashParams);
        });
    });
    describe('Block full app access while naviagting from embed app', () => {
        it('should contain blockNonEmbedFullAppAccess as false in query params', async () => {
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.None,
                blockNonEmbedFullAppAccess: false,
            });
            const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                frameParams: {
                    width: '100%',
                    height: '100%',
                },
            });
            appEmbed.render();
            await (0, test_utils_1.waitFor)(() => !!(0, test_utils_1.getIFrameEl)()).then(() => {
                expect((0, test_utils_1.getIFrameSrc)()).toContain('blockNonEmbedFullAppAccess=false');
            });
        });
        it('should contain blockNonEmbedFullAppAccess as true in query params', async () => {
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.None,
            });
            const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                frameParams: {
                    width: '100%',
                    height: '100%',
                },
            });
            appEmbed.render();
            await (0, test_utils_1.waitFor)(() => !!(0, test_utils_1.getIFrameEl)()).then(() => {
                expect((0, test_utils_1.getIFrameSrc)()).toContain('blockNonEmbedFullAppAccess=true');
            });
        });
    });
    describe('validate preRender flow', () => {
        beforeAll(() => {
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.None,
            });
        });
        afterAll(() => {
            const rootEle = document.getElementById('myRoot');
            rootEle === null || rootEle === void 0 ? void 0 : rootEle.remove();
            jest.clearAllMocks();
        });
        it('should preRender and hide the iframe', async () => {
            (0, test_utils_1.createRootEleForEmbed)();
            const libEmbed = new index_1.LiveboardEmbed('#tsEmbedDiv', {
                preRenderId: 'i-am-preRendered',
                liveboardId: 'myLiveboardId',
            });
            libEmbed.preRender();
            await (0, test_utils_1.waitFor)(() => !!(0, test_utils_1.getIFrameEl)());
            const preRenderIds = libEmbed.getPreRenderIds();
            const preRenderWrapper = document.getElementById(preRenderIds.wrapper);
            expect(preRenderWrapper.style.opacity).toBe('0');
            expect(preRenderWrapper.style.pointerEvents).toBe('none');
            expect(preRenderWrapper.style.zIndex).toBe('-1000');
            const preRenderChild = document.getElementById(preRenderIds.child);
            expect(preRenderWrapper.children[0]).toEqual(preRenderChild);
            expect(preRenderChild).toBeInstanceOf(HTMLIFrameElement);
            expect(preRenderChild.src).toMatch(/^http:\/\/tshost.*\/myLiveboardId/);
            const tsEmbedDiv = document.getElementById('tsEmbedDiv');
            tsEmbedDiv.style.width = '100px';
            tsEmbedDiv.style.height = '100px';
            let resizeObserverCb;
            window.ResizeObserver = window.ResizeObserver
                || jest.fn().mockImplementation((resizeObserverCbParam) => {
                    resizeObserverCb = resizeObserverCbParam;
                    return {
                        disconnect: jest.fn(),
                        observe: jest.fn(),
                        unobserve: jest.fn(),
                    };
                });
            // show preRender
            const warnSpy = jest.spyOn(logger_1.logger, 'warn');
            libEmbed.showPreRender();
            expect(warnSpy).toHaveBeenCalledTimes(1);
            resizeObserverCb([
                {
                    target: tsEmbedDiv,
                    contentRect: { height: 297, width: 987 },
                },
            ]);
            expect(preRenderWrapper.style.height).toEqual(`${297}px`);
            expect(preRenderWrapper.style.width).toEqual(`${987}px`);
            expect(preRenderWrapper.style.opacity).toBe('');
            expect(preRenderWrapper.style.pointerEvents).toBe('');
            expect(preRenderWrapper.style.zIndex).toBe('');
            libEmbed.hidePreRender();
            expect(preRenderWrapper.style.opacity).toBe('0');
            expect(preRenderWrapper.style.pointerEvents).toBe('none');
            expect(preRenderWrapper.style.zIndex).toBe('-1000');
            libEmbed.destroy();
            expect(document.getElementById(preRenderIds.wrapper)).toBe(null);
        });
        it('preRender called without preRenderId should log error ', () => {
            (0, test_utils_1.createRootEleForEmbed)();
            jest.spyOn(logger_1.logger, 'error');
            const libEmbed = new index_1.LiveboardEmbed('#tsEmbedDiv', {
                liveboardId: 'myLiveboardId',
            });
            libEmbed.preRender();
            expect(logger_1.logger.error).toHaveBeenCalledWith('PreRender ID is required for preRender');
        });
        it('showPreRender should preRender if not available', async () => {
            (0, test_utils_1.createRootEleForEmbed)();
            const libEmbed = new index_1.LiveboardEmbed('#tsEmbedDiv', {
                preRenderId: 'i-am-preRendered',
                liveboardId: 'myLiveboardId',
            });
            const preRenderIds = libEmbed.getPreRenderIds();
            libEmbed.showPreRender();
            await (0, test_utils_1.waitFor)(() => !!(0, test_utils_1.getIFrameEl)());
            const preRenderWrapper = document.getElementById(preRenderIds.wrapper);
            expect(preRenderWrapper.style.opacity).toBe('');
            expect(preRenderWrapper.style.pointerEvents).toBe('');
            expect(preRenderWrapper.style.zIndex).toBe('');
        });
        it('hidePreRender should not preRender if not available', async () => {
            (0, test_utils_1.createRootEleForEmbed)();
            const libEmbed = new index_1.LiveboardEmbed('#tsEmbedDiv', {
                preRenderId: 'i-am-preRendered',
                liveboardId: 'myLiveboardId',
            });
            jest.spyOn(libEmbed, 'preRender');
            libEmbed.hidePreRender();
            expect(libEmbed.preRender).toHaveBeenCalledTimes(0);
        });
        it('should set overflow:hidden when hidePreRender and remove when showPreRender', async () => {
            (0, test_utils_1.createRootEleForEmbed)();
            window.ResizeObserver = window.ResizeObserver
                || jest.fn().mockImplementation(() => ({
                    disconnect: jest.fn(),
                    observe: jest.fn(),
                    unobserve: jest.fn(),
                }));
            const libEmbed = new index_1.LiveboardEmbed('#tsEmbedDiv', {
                preRenderId: 'overflow-test',
                liveboardId: 'myLiveboardId',
            });
            await libEmbed.preRender();
            await (0, test_utils_1.waitFor)(() => !!(0, test_utils_1.getIFrameEl)());
            const preRenderIds = libEmbed.getPreRenderIds();
            const preRenderWrapper = document.getElementById(preRenderIds.wrapper);
            // After preRender (calls hidePreRender by default)
            // should have overflow:hidden
            expect(preRenderWrapper.style.overflow).toBe('hidden');
            expect(preRenderWrapper.style.opacity).toBe('0');
            // After showPreRender, overflow should be removed
            // to inherit from CSS
            libEmbed.showPreRender();
            expect(preRenderWrapper.style.overflow).toBe('');
            expect(preRenderWrapper.style.opacity).toBe('');
            // After hidePreRender again, overflow should be hidden
            libEmbed.hidePreRender();
            expect(preRenderWrapper.style.overflow).toBe('hidden');
            expect(preRenderWrapper.style.opacity).toBe('0');
        });
        it('it should connect with another object', async () => {
            (0, test_utils_1.createRootEleForEmbed)();
            (0, test_utils_1.mockMessageChannel)();
            window.ResizeObserver = window.ResizeObserver
                || jest.fn().mockImplementation(() => ({
                    disconnect: jest.fn(),
                    observe: jest.fn(),
                    unobserve: jest.fn(),
                }));
            const libEmbed = new index_1.LiveboardEmbed('#tsEmbedDiv', {
                preRenderId: 'i-am-preRendered',
                liveboardId: 'myLiveboardId',
            });
            libEmbed.preRender();
            await (0, test_utils_1.waitFor)(() => !!(0, test_utils_1.getIFrameEl)());
            const warnSpy = jest.spyOn(logger_1.logger, 'warn');
            const newEmbed = new index_1.LiveboardEmbed('#tsEmbedDiv', {
                preRenderId: 'i-am-preRendered',
                liveboardId: 'awdawda',
                hiddenActions: [types_1.Action.AddFilter],
                frameParams: { height: 90 },
            });
            newEmbed.showPreRender();
            expect(warnSpy).toHaveBeenCalledTimes(2);
        });
        it('showPreRender should not preRender if not available', async () => {
            (0, test_utils_1.createRootEleForEmbed)();
            const libEmbed = new index_1.LiveboardEmbed('#tsEmbedDiv', {
                liveboardId: 'myLiveboardId',
            });
            jest.spyOn(libEmbed, 'preRender');
            jest.spyOn(logger_1.logger, 'error');
            libEmbed.showPreRender();
            expect(libEmbed.preRender).toHaveBeenCalledTimes(0);
            expect(logger_1.logger.error).toHaveBeenCalledTimes(1);
        });
        it('should get underlying iframe', async () => {
            (0, test_utils_1.createRootEleForEmbed)();
            const libEmbed = new index_1.LiveboardEmbed('#tsEmbedDiv', {
                liveboardId: 'myLiveboardId',
            });
            libEmbed.render();
            await (0, test_utils_1.waitFor)(() => !!(0, test_utils_1.getIFrameEl)());
            expect(libEmbed.getUnderlyingFrameElement()).toEqual((0, test_utils_1.getIFrameEl)());
        });
        it('should render error message properly', async () => {
            jest.spyOn(baseInstance, 'getAuthPromise').mockResolvedValueOnce(false);
            const libEmbed = new index_1.LiveboardEmbed('#tsEmbedDiv', {
                liveboardId: 'myLiveboardId',
                preRenderId: 'test',
            });
            await libEmbed.preRender();
            expect(document.getElementById('tsEmbed-pre-render-child-test').innerHTML).toBe('Not logged in');
        });
        it('should log error if sync is called before preRender', async () => {
            jest.spyOn(logger_1.logger, 'error').mockImplementation(jest.fn());
            const libEmbed = new index_1.LiveboardEmbed('#tsEmbedDiv', {
                liveboardId: 'myLiveboardId',
                preRenderId: 'test',
            });
            await libEmbed.syncPreRenderStyle();
            expect(logger_1.logger.error).toHaveBeenCalledWith('PreRender should be called before using syncPreRenderStyle');
            logger_1.logger.error.mockClear();
        });
    });
    describe('IdleSessionTimeout embedEvent for TrustedAuthTokenCookieless authType with autoLogin true', () => {
        beforeAll(() => {
            jest.spyOn(authInstance, 'doCookielessTokenAuth').mockResolvedValueOnce(true);
            jest.spyOn(authService, 'verifyTokenService').mockResolvedValueOnce(true);
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                customizations: customisations,
                authType: index_1.AuthType.TrustedAuthTokenCookieless,
                getAuthToken: () => Promise.resolve('test_auth_token2'),
                autoLogin: true,
            });
        });
        test('should handle idle session timeout and send updated auth token', async () => {
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.IdleSessionTimeout,
                data: {},
            };
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            jest.spyOn(baseInstance, 'handleAuth');
            jest.spyOn(baseInstance, 'notifyAuthFailure');
            searchEmbed.render();
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(baseInstance.notifyAuthFailure).toHaveBeenCalledWith(authInstance.AuthFailureType.IDLE_SESSION_TIMEOUT);
                expect(baseInstance.handleAuth).toHaveBeenCalled();
                expect(mockPort.postMessage).toHaveBeenCalledWith({
                    type: index_1.EmbedEvent.IdleSessionTimeout,
                    data: { authToken: 'test_auth_token2' },
                });
            });
        });
        test('should handle idle session timeout and show login failure message if token fetch fails', async () => {
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                customizations: customisations,
                authType: index_1.AuthType.TrustedAuthTokenCookieless,
                getAuthToken: () => Promise.reject(),
                autoLogin: true,
            });
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.IdleSessionTimeout,
                data: {},
            };
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            jest.spyOn(baseInstance, 'notifyAuthFailure');
            searchEmbed.render();
            const mockPort = {
                postMessage: jest.fn(),
            };
            const loggerSpy = jest.spyOn(logger_1.logger, 'error').mockImplementation(() => { });
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect((0, test_utils_1.getRootEl)().innerHTML).toContain('Not logged in');
                expect(baseInstance.notifyAuthFailure).toHaveBeenCalledWith(authInstance.AuthFailureType.IDLE_SESSION_TIMEOUT);
                expect(loggerSpy).toHaveBeenCalledTimes(1);
            });
            jest.spyOn(authService, 'verifyTokenService').mockClear();
            jest.spyOn(baseInstance, 'notifyAuthFailure').mockClear();
        });
        test('should handle idle session timeout and show login failure message if handleAuth fails', async () => {
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                customizations: customisations,
                authType: index_1.AuthType.TrustedAuthTokenCookieless,
                getAuthToken: () => Promise.resolve('test_auth_token2'),
                autoLogin: true,
            });
            const mockEmbedEventPayload = {
                type: index_1.EmbedEvent.IdleSessionTimeout,
                data: {},
            };
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            jest.spyOn(baseInstance, 'notifyAuthFailure');
            jest.spyOn(authInstance, 'authenticate').mockResolvedValue(false);
            searchEmbed.render();
            const mockPort = {
                postMessage: jest.fn(),
            };
            const loggerSpy = jest.spyOn(logger_1.logger, 'error').mockImplementation(() => { });
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(baseInstance.notifyAuthFailure).toHaveBeenCalledWith(authInstance.AuthFailureType.IDLE_SESSION_TIMEOUT);
                expect(loggerSpy).toHaveBeenCalledTimes(0);
            });
            jest.spyOn(authService, 'verifyTokenService').mockClear();
            jest.spyOn(baseInstance, 'notifyAuthFailure').mockClear();
        });
    });
    describe('Renders should wait for init to completed', () => {
        const errorSpy = jest.spyOn(logger_1.logger, 'error').mockImplementation(() => { });
        beforeEach(() => {
            errorSpy.mockClear();
            (0, utils_1.resetValueFromWindow)('initFlagKey');
            baseInstance.createAndSetInitPromise();
            document.body.innerHTML = (0, test_utils_1.getDocumentBody)();
        });
        test('Pre-render should wait for init to complete', async () => {
            const lib = new index_1.LiveboardEmbed((0, test_utils_1.getRootEl)(), { preRenderId: 'test', liveboardId: 'test' });
            lib.preRender();
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(errorSpy).toHaveBeenCalledWith(errors_1.ERROR_MESSAGE.RENDER_CALLED_BEFORE_INIT);
                expect((0, test_utils_1.getRootEl)().innerHTML).toContain('');
            });
            const iframeBeforeInit = (0, test_utils_1.getIFrameEl)();
            expect(iframeBeforeInit).toBe(null);
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.None,
            });
            await (0, test_utils_1.waitFor)(() => !!(0, test_utils_1.getIFrameEl)());
            const preRenderId = lib.getPreRenderIds().wrapper;
            expect(document.getElementById(preRenderId)).not.toBe(null);
            const iframeAfterInit = (0, test_utils_1.getIFrameEl)();
            expect(iframeAfterInit).not.toBe(null);
        });
        test('Render should wait for init to complete', async () => {
            const lib = new index_1.LiveboardEmbed((0, test_utils_1.getRootEl)(), { liveboardId: 'test' });
            lib.render();
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(errorSpy).toHaveBeenCalledWith(errors_1.ERROR_MESSAGE.RENDER_CALLED_BEFORE_INIT);
                expect((0, test_utils_1.getRootEl)().innerHTML).toContain('');
            });
            const iframeBeforeInit = (0, test_utils_1.getIFrameEl)();
            expect(iframeBeforeInit).toBe(null);
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.None,
            });
            await (0, test_utils_1.waitFor)(() => !!(0, test_utils_1.getIFrameEl)());
            expect((0, test_utils_1.getRootEl)()).not.toBe(null);
            const iframeAfterInit = (0, test_utils_1.getIFrameEl)();
            expect(iframeAfterInit).not.toBe(null);
        });
        test('Pre Render Generic should wait for init to complete', async () => {
            const lib = new index_1.LiveboardEmbed((0, test_utils_1.getRootEl)(), {});
            lib.prerenderGeneric();
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(errorSpy).toHaveBeenCalledWith(errors_1.ERROR_MESSAGE.RENDER_CALLED_BEFORE_INIT);
                expect((0, test_utils_1.getRootEl)().innerHTML).toContain('');
            });
            const iframeBeforeInit = (0, test_utils_1.getIFrameEl)();
            expect(iframeBeforeInit).toBe(null);
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.None,
            });
            await (0, test_utils_1.waitFor)(() => !!(0, test_utils_1.getIFrameEl)());
            expect((0, test_utils_1.getRootEl)()).not.toBe(null);
            const iframeAfterInit = (0, test_utils_1.getIFrameEl)();
            expect(iframeAfterInit).not.toBe(null);
        });
    });
    describe('AutoLogin behavior in updateAuthToken', () => {
        const mockPort = { postMessage: jest.fn() };
        const mockEmbedEventPayload = { type: index_1.EmbedEvent.AuthExpire, data: {} };
        beforeEach(() => {
            jest.clearAllMocks();
            document.body.innerHTML = (0, test_utils_1.getDocumentBody)();
            mockPort.postMessage.mockClear();
            jest.spyOn(authToken, 'getAuthenticationToken').mockResolvedValue('mock-test-token-placeholder');
            jest.spyOn(baseInstance, 'handleAuth').mockImplementation(() => Promise.resolve(true));
            jest.spyOn(baseInstance, 'notifyAuthFailure').mockImplementation(() => { });
        });
        const renderAndTriggerAuthExpire = async () => {
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            await searchEmbed.render();
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload, mockPort);
            });
        };
        test('Cookieless with autoLogin undefined should default to true', async () => {
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.TrustedAuthTokenCookieless,
                // autoLogin undefined
            });
            await renderAndTriggerAuthExpire();
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(authToken.getAuthenticationToken).toHaveBeenCalled();
                expect(baseInstance.handleAuth).toHaveBeenCalledTimes(1);
                expect(mockPort.postMessage).toHaveBeenCalledWith({
                    type: index_1.EmbedEvent.AuthExpire,
                    data: { authToken: 'mock-test-token-placeholder' },
                });
            });
        });
        test('Cookieless with autoLogin false should not get auth token', async () => {
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.TrustedAuthTokenCookieless,
                autoLogin: false,
            });
            await renderAndTriggerAuthExpire();
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(authToken.getAuthenticationToken).not.toHaveBeenCalled();
                expect(baseInstance.handleAuth).toHaveBeenCalledTimes(1);
                expect(mockPort.postMessage).not.toHaveBeenCalled();
            });
        });
        test('Cookieless with autoLogin true should get auth token', async () => {
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.TrustedAuthTokenCookieless,
                autoLogin: true,
            });
            await renderAndTriggerAuthExpire();
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(authToken.getAuthenticationToken).toHaveBeenCalled();
                expect(baseInstance.handleAuth).toHaveBeenCalledTimes(1);
                expect(mockPort.postMessage).toHaveBeenCalledWith({
                    type: index_1.EmbedEvent.AuthExpire,
                    data: { authToken: 'mock-test-token-placeholder' },
                });
            });
        });
        test('Other authType with autoLogin undefined should default to false', async () => {
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.None,
                // autoLogin undefined
            });
            await renderAndTriggerAuthExpire();
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(authToken.getAuthenticationToken).not.toHaveBeenCalled();
                expect(baseInstance.handleAuth).toHaveBeenCalledTimes(1);
            });
        });
        test('Other authType with autoLogin true should call handleAuth', async () => {
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.None,
                autoLogin: true,
            });
            await renderAndTriggerAuthExpire();
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(authToken.getAuthenticationToken).not.toHaveBeenCalled();
                expect(baseInstance.handleAuth).toHaveBeenCalledTimes(2);
            });
        });
        test('Other authType with autoLogin false should not call handleAuth', async () => {
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.None,
                autoLogin: false,
            });
            await renderAndTriggerAuthExpire();
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(authToken.getAuthenticationToken).not.toHaveBeenCalled();
                expect(baseInstance.handleAuth).toHaveBeenCalledTimes(1);
            });
        });
        afterEach(() => {
            expect(baseInstance.notifyAuthFailure).toHaveBeenCalledWith(authInstance.AuthFailureType.EXPIRY);
        });
    });
    describe('AutoLogin behavior in tokenRefresh', () => {
        const mockPort = { postMessage: jest.fn() };
        const mockEmbedEventPayload = { type: index_1.EmbedEvent.RefreshAuthToken, data: {} };
        beforeEach(() => {
            jest.clearAllMocks();
            document.body.innerHTML = (0, test_utils_1.getDocumentBody)();
            mockPort.postMessage.mockClear();
            jest.spyOn(authToken, 'getAuthenticationToken').mockResolvedValue('mock-test-token-placeholder');
            jest.spyOn(processData, 'processAuthFailure').mockImplementation(() => ({}));
            jest.spyOn(logger_1.logger, 'error').mockImplementation(() => { });
        });
        const renderAndTriggerRefreshAuthToken = async () => {
            const spotterEmbed = new index_1.SpotterEmbed((0, test_utils_1.getRootEl)(), {
                worksheetId: 'test-worksheet',
                searchOptions: {
                    searchQuery: 'test query',
                },
            });
            await spotterEmbed.render();
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEmbedEventPayload, mockPort);
            });
        };
        test('Cookieless with autoLogin undefined should default to true and refresh token', async () => {
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.TrustedAuthTokenCookieless,
                // autoLogin undefined
            });
            await renderAndTriggerRefreshAuthToken();
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(authToken.getAuthenticationToken).toHaveBeenCalledWith(expect.any(Object), true);
            });
        });
        test('Cookieless with autoLogin true should refresh token', async () => {
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.TrustedAuthTokenCookieless,
                autoLogin: true,
            });
            await renderAndTriggerRefreshAuthToken();
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(authToken.getAuthenticationToken).toHaveBeenCalledWith(expect.any(Object), true);
            });
        });
        test('Cookieless with autoLogin false should not refresh token', async () => {
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.TrustedAuthTokenCookieless,
                autoLogin: false,
            });
            await renderAndTriggerRefreshAuthToken();
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(authToken.getAuthenticationToken).not.toHaveBeenCalled();
                expect(mockPort.postMessage).not.toHaveBeenCalled();
            });
        });
        test('Should handle error when getAuthenticationToken fails', async () => {
            const error = new Error('Token fetch failed');
            jest.spyOn(authToken, 'getAuthenticationToken').mockRejectedValue(error);
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.TrustedAuthTokenCookieless,
                autoLogin: true,
            });
            await renderAndTriggerRefreshAuthToken();
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(authToken.getAuthenticationToken).toHaveBeenCalledWith(expect.any(Object), true);
                // Check that logger.error was called with the token refresh error
                const errorCalls = logger_1.logger.error.mock.calls.filter((call) => { var _a, _b; return ((_a = call[0]) === null || _a === void 0 ? void 0 : _a.includes(errors_1.ERROR_MESSAGE.INVALID_TOKEN_ERROR)) && ((_b = call[0]) === null || _b === void 0 ? void 0 : _b.includes('Token fetch failed')); });
                expect(errorCalls.length).toBeGreaterThan(0);
                expect(processData.processAuthFailure).toHaveBeenCalledWith(error, expect.any(Element));
                expect(mockPort.postMessage).not.toHaveBeenCalled();
            });
        });
    });
    describe('Fullscreen Change Handler', () => {
        beforeEach(() => {
            document.body.innerHTML = (0, test_utils_1.getDocumentBody)();
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.None,
                disableFullscreenPresentation: false,
            });
        });
        test('should have setupFullscreenChangeHandler method', () => {
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            expect(typeof searchEmbed['setupFullscreenChangeHandler']).toBe('function');
        });
        test('should have removeFullscreenChangeHandler method', () => {
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            expect(typeof searchEmbed['removeFullscreenChangeHandler']).toBe('function');
        });
        test('should call setupFullscreenChangeHandler without errors', () => {
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            expect(() => {
                searchEmbed['setupFullscreenChangeHandler']();
            }).not.toThrow();
        });
        test('should call removeFullscreenChangeHandler without errors', () => {
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            expect(() => {
                searchEmbed['removeFullscreenChangeHandler']();
            }).not.toThrow();
        });
        test('should handle fullscreen change when feature flag is disabled', () => {
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.None,
                disableFullscreenPresentation: true,
            });
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            expect(() => {
                searchEmbed['setupFullscreenChangeHandler']();
            }).not.toThrow();
        });
    });
    describe('Embed Container Loading', () => {
        beforeEach(() => {
            document.body.innerHTML = (0, test_utils_1.getDocumentBody)();
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.None,
            });
            jest.spyOn(sessionInfoService, 'getSessionInfo').mockResolvedValue({
                releaseVersion: '1.0.0',
                userGUID: '1234567890',
                currentOrgId: 1,
                privileges: [],
                mixpanelToken: '1234567890',
                isPublicUser: false,
                clusterId: 'cluster1',
                clusterName: 'Test Cluster',
            });
        });
        test('should initialize with isEmbedContainerLoaded as false', () => {
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            expect(searchEmbed.isEmbedContainerLoaded).toBe(false);
        });
        test('should have empty embedContainerReadyCallbacks array initially', () => {
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            expect(searchEmbed['embedContainerReadyCallbacks']).toEqual([]);
        });
        test('should execute callback immediately if embed container is already loaded', () => {
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            searchEmbed.isEmbedContainerLoaded = true;
            const callback = jest.fn();
            searchEmbed['executeAfterEmbedContainerLoaded'](callback);
            expect(callback).toHaveBeenCalledTimes(1);
        });
        test('should queue callback if embed container is not loaded', () => {
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            searchEmbed.isEmbedContainerLoaded = false;
            const callback = jest.fn();
            searchEmbed['executeAfterEmbedContainerLoaded'](callback);
            expect(callback).not.toHaveBeenCalled();
            expect(searchEmbed['embedContainerReadyCallbacks']).toContain(callback);
        });
        test('should execute all queued callbacks when embed container becomes ready', () => {
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            searchEmbed.isEmbedContainerLoaded = false;
            const callback1 = jest.fn();
            const callback2 = jest.fn();
            const callback3 = jest.fn();
            searchEmbed['executeAfterEmbedContainerLoaded'](callback1);
            searchEmbed['executeAfterEmbedContainerLoaded'](callback2);
            searchEmbed['executeAfterEmbedContainerLoaded'](callback3);
            expect(callback1).not.toHaveBeenCalled();
            expect(callback2).not.toHaveBeenCalled();
            expect(callback3).not.toHaveBeenCalled();
            // Simulate embed container becoming ready
            searchEmbed['executeEmbedContainerReadyCallbacks']();
            expect(callback1).toHaveBeenCalledTimes(1);
            expect(callback2).toHaveBeenCalledTimes(1);
            expect(callback3).toHaveBeenCalledTimes(1);
        });
        test('should handle AuthInit event and set embed container as loaded after timeout', async () => {
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            searchEmbed.render();
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                expect(iframe).toBeTruthy();
            });
            const iframe = (0, test_utils_1.getIFrameEl)();
            const callback = jest.fn();
            searchEmbed['executeAfterEmbedContainerLoaded'](callback);
            // Simulate AuthInit event
            (0, test_utils_1.postMessageToParent)(iframe.contentWindow, {
                type: index_1.EmbedEvent.AuthInit,
            });
            expect(callback).not.toHaveBeenCalled();
            expect(searchEmbed.isEmbedContainerLoaded).toBe(false);
            // Wait for the 1-second timeout
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(searchEmbed.isEmbedContainerLoaded).toBe(true);
                expect(callback).toHaveBeenCalledTimes(1);
            }, 1100);
        });
        test('should handle EmbedListenerReady event and set embed container as loaded immediately', async () => {
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            searchEmbed.render();
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                expect(iframe).toBeTruthy();
            });
            const iframe = (0, test_utils_1.getIFrameEl)();
            const callback = jest.fn();
            searchEmbed['executeAfterEmbedContainerLoaded'](callback);
            // Simulate EmbedListenerReady event
            (0, test_utils_1.postMessageToParent)(iframe.contentWindow, {
                type: index_1.EmbedEvent.EmbedListenerReady,
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(searchEmbed.isEmbedContainerLoaded).toBe(true);
                expect(callback).toHaveBeenCalledTimes(1);
            });
        });
        test('should check prerendered object for embed container loaded state', () => {
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            // Mock a prerendered object with loaded state
            const mockPreRenderObj = {
                isEmbedContainerLoaded: true,
            };
            jest.spyOn(searchEmbed, 'getPreRenderObj').mockReturnValue(mockPreRenderObj);
            const result = searchEmbed['checkEmbedContainerLoaded']();
            expect(result).toBe(true);
            expect(searchEmbed.isEmbedContainerLoaded).toBe(true);
        });
        test('should return getPreRenderObj and log if same object', () => {
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            const loggerSpy = jest.spyOn(logger_1.logger, 'info');
            // Mock insertedDomEl to have the embed object
            searchEmbed.insertedDomEl = {
                [searchEmbed['embedNodeKey']]: searchEmbed,
            };
            const result = searchEmbed['getPreRenderObj']();
            expect(result).toBe(searchEmbed);
            expect(loggerSpy).toHaveBeenCalledWith('embedObj is same as this');
        });
        test('should handle null/undefined callbacks gracefully', () => {
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            expect(() => {
                searchEmbed['executeAfterEmbedContainerLoaded'](null);
                searchEmbed['executeAfterEmbedContainerLoaded'](undefined);
            }).not.toThrow();
        });
        test('should handle multiple callback executions correctly', () => {
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            const callback1 = jest.fn();
            const callback2 = jest.fn();
            // Add callbacks when container is not loaded
            searchEmbed['executeAfterEmbedContainerLoaded'](callback1);
            searchEmbed['executeAfterEmbedContainerLoaded'](callback2);
            // Execute callbacks
            searchEmbed['executeEmbedContainerReadyCallbacks']();
            expect(callback1).toHaveBeenCalledTimes(1);
            expect(callback2).toHaveBeenCalledTimes(1);
            // Add another callback after container is loaded
            searchEmbed.isEmbedContainerLoaded = true;
            const callback3 = jest.fn();
            searchEmbed['executeAfterEmbedContainerLoaded'](callback3);
            expect(callback3).toHaveBeenCalledTimes(1);
        });
        describe('getCurrentContext', () => {
            const mockContext = {
                stack: [
                    {
                        name: 'Liveboard',
                        type: 'Liveboard',
                        objectIds: { liveboardId: 'lb-123' },
                    },
                ],
                currentContext: {
                    name: 'Liveboard',
                    type: 'Liveboard',
                    objectIds: { liveboardId: 'lb-123' },
                },
            };
            test('should return context when embed container is already loaded', async () => {
                const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
                searchEmbed.isEmbedContainerLoaded = true;
                const triggerSpy = jest.spyOn(searchEmbed, 'trigger')
                    .mockResolvedValue(mockContext);
                const context = await searchEmbed.getCurrentContext();
                expect(context).toEqual(mockContext);
                expect(triggerSpy).toHaveBeenCalledWith(types_1.HostEvent.GetPageContext, {});
            });
            test('should wait for embed container to load before returning context', async () => {
                const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
                searchEmbed.isEmbedContainerLoaded = false;
                const triggerSpy = jest.spyOn(searchEmbed, 'trigger')
                    .mockResolvedValue(mockContext);
                const contextPromise = searchEmbed.getCurrentContext();
                // Context should not be resolved yet
                await (0, test_utils_1.executeAfterWait)(() => {
                    expect(triggerSpy).not.toHaveBeenCalled();
                }, 10);
                // Simulate embed container becoming ready
                searchEmbed['executeEmbedContainerReadyCallbacks']();
                const context = await contextPromise;
                expect(context).toEqual(mockContext);
                expect(triggerSpy).toHaveBeenCalledWith(types_1.HostEvent.GetPageContext, {});
            });
        });
        test('should register embed container event handlers during construction', () => {
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            // Check that the event handlers are registered
            const eventHandlerMap = searchEmbed['eventHandlerMap'];
            expect(eventHandlerMap.has(index_1.EmbedEvent.AuthInit)).toBe(true);
            expect(eventHandlerMap.has(index_1.EmbedEvent.EmbedListenerReady)).toBe(true);
        });
        test('should handle handleEmbedContainerLoaded with AuthInit source', () => {
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            jest.useFakeTimers();
            const handler = searchEmbed['createEmbedContainerHandler'](index_1.EmbedEvent.AuthInit);
            expect(searchEmbed.isEmbedContainerLoaded).toBe(false);
            handler();
            expect(searchEmbed.isEmbedContainerLoaded).toBe(false);
            // Fast-forward time
            jest.advanceTimersByTime(1000);
            expect(searchEmbed.isEmbedContainerLoaded).toBe(true);
            jest.useRealTimers();
        });
        test('should handle handleEmbedContainerLoaded with EmbedListenerReady source', () => {
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            const handler = searchEmbed['createEmbedContainerHandler'](index_1.EmbedEvent.EmbedListenerReady);
            expect(searchEmbed.isEmbedContainerLoaded).toBe(false);
            handler();
            expect(searchEmbed.isEmbedContainerLoaded).toBe(true);
        });
    });
    describe('Online event listener registration after auth failure', () => {
        beforeAll(() => {
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.None,
                loginFailedMessage: 'Not logged in',
            });
        });
        test('should register online event listener when authentication fails', async () => {
            const addEventListenerSpy = jest.spyOn(window, 'addEventListener');
            jest.spyOn(baseInstance, 'getAuthPromise').mockRejectedValueOnce(new Error('Auth failed'));
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            addEventListenerSpy.mockClear();
            await searchEmbed.render();
            await (0, test_utils_1.executeAfterWait)(() => {
                expect((0, test_utils_1.getRootEl)().innerHTML).toContain('Not logged in');
                const onlineListenerCalls = addEventListenerSpy.mock.calls.filter((call) => call[0] === 'online');
                expect(onlineListenerCalls).toHaveLength(1);
                const offlineListenerCalls = addEventListenerSpy.mock.calls.filter((call) => call[0] === 'offline');
                expect(offlineListenerCalls).toHaveLength(1);
                const messageListenerCalls = addEventListenerSpy.mock.calls.filter((call) => call[0] === 'message');
                expect(messageListenerCalls).toHaveLength(0);
            });
            addEventListenerSpy.mockRestore();
        });
        test('should attempt to trigger reload when online event occurs after auth failure', async () => {
            jest.spyOn(baseInstance, 'getAuthPromise').mockRejectedValueOnce(new Error('Auth failed'));
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            const triggerSpy = jest.spyOn(searchEmbed, 'trigger').mockResolvedValue(null);
            await searchEmbed.render();
            await (0, test_utils_1.executeAfterWait)(() => {
                expect((0, test_utils_1.getRootEl)().innerHTML).toContain('Not logged in');
                triggerSpy.mockClear();
                const onlineEvent = new Event('online');
                window.dispatchEvent(onlineEvent);
                expect(triggerSpy).toHaveBeenCalledWith(types_1.HostEvent.Reload);
            });
            triggerSpy.mockReset();
        });
        test('should handle online event gracefully when no iframe exists', async () => {
            jest.spyOn(baseInstance, 'getAuthPromise').mockRejectedValueOnce(new Error('Auth failed'));
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            const errorSpy = jest.spyOn(console, 'error').mockImplementation(() => { });
            await searchEmbed.render();
            await (0, test_utils_1.executeAfterWait)(() => {
                expect((0, test_utils_1.getRootEl)().innerHTML).toContain('Not logged in');
                const onlineEvent = new Event('online');
                expect(() => {
                    window.dispatchEvent(onlineEvent);
                }).not.toThrow();
            });
            errorSpy.mockReset();
        });
        test('should register all event listeners when authentication succeeds', async () => {
            const addEventListenerSpy = jest.spyOn(window, 'addEventListener');
            jest.spyOn(baseInstance, 'getAuthPromise').mockResolvedValueOnce(true);
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            addEventListenerSpy.mockClear();
            await searchEmbed.render();
            await (0, test_utils_1.executeAfterWait)(() => {
                const onlineListenerCalls = addEventListenerSpy.mock.calls.filter((call) => call[0] === 'online');
                expect(onlineListenerCalls).toHaveLength(1);
                const offlineListenerCalls = addEventListenerSpy.mock.calls.filter((call) => call[0] === 'offline');
                expect(offlineListenerCalls).toHaveLength(1);
                const messageListenerCalls = addEventListenerSpy.mock.calls.filter((call) => call[0] === 'message');
                expect(messageListenerCalls).toHaveLength(1);
            });
            addEventListenerSpy.mockRestore();
        });
        test('should successfully trigger reload when online event occurs after auth success', async () => {
            jest.spyOn(baseInstance, 'getAuthPromise').mockResolvedValueOnce(true);
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            const triggerSpy = jest.spyOn(searchEmbed, 'trigger').mockResolvedValue({});
            await searchEmbed.render();
            await (0, test_utils_1.executeAfterWait)(() => {
                triggerSpy.mockClear();
                const onlineEvent = new Event('online');
                window.dispatchEvent(onlineEvent);
                expect(triggerSpy).toHaveBeenCalledWith(types_1.HostEvent.Reload);
            });
            triggerSpy.mockReset();
        });
    });
    describe('When destroyed', () => {
        it('should remove the iframe', async () => {
            const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                frameParams: {
                    width: '100%',
                    height: '100%',
                },
            });
            await appEmbed.render();
            expect((0, test_utils_1.getIFrameEl)()).toBeTruthy();
            appEmbed.destroy();
            expect((0, test_utils_1.getIFrameEl)()).toBeFalsy();
        });
        it('should remove the iframe when insertAsSibling is true', async () => {
            const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                frameParams: {
                    width: '100%',
                    height: '100%',
                },
                insertAsSibling: true,
            });
            await appEmbed.render();
            expect((0, test_utils_1.getIFrameEl)()).toBeTruthy();
            appEmbed.destroy();
            expect((0, test_utils_1.getIFrameEl)()).toBeFalsy();
        });
        it("Should remove the error message on destroy if it's present", async () => {
            jest.spyOn(baseInstance, 'getAuthPromise').mockResolvedValueOnce(false);
            const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                frameParams: {
                    width: '100%',
                    height: '100%',
                },
                insertAsSibling: true,
            });
            await appEmbed.render();
            expect((0, test_utils_1.getRootEl)().nextElementSibling.innerHTML).toContain('Not logged in');
            appEmbed.destroy();
            expect((0, test_utils_1.getRootEl)().nextElementSibling.innerHTML).toBe('');
        });
        describe('with waitForCleanupOnDestroy configuration', () => {
            let originalEmbedConfig;
            beforeEach(() => {
                originalEmbedConfig = embedConfig.getEmbedConfig();
            });
            afterEach(() => {
                embedConfig.setEmbedConfig(originalEmbedConfig);
            });
            it('should trigger DestroyEmbed event immediately when waitForCleanupOnDestroy is false', async () => {
                embedConfig.setEmbedConfig({
                    ...originalEmbedConfig,
                    waitForCleanupOnDestroy: false,
                });
                const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                    frameParams: {
                        width: '100%',
                        height: '100%',
                    },
                });
                await appEmbed.render();
                const triggerSpy = jest.spyOn(appEmbed, 'trigger').mockResolvedValue(null);
                const removeChildSpy = jest.spyOn(Node.prototype, 'removeChild').mockImplementation(() => (0, test_utils_1.getRootEl)());
                appEmbed.destroy();
                expect(triggerSpy).toHaveBeenCalledWith(types_1.HostEvent.DestroyEmbed);
                expect(removeChildSpy).toHaveBeenCalled();
            });
            it('should trigger DestroyEmbed event and wait for cleanup when waitForCleanupOnDestroy is true', async () => {
                embedConfig.setEmbedConfig({
                    ...originalEmbedConfig,
                    waitForCleanupOnDestroy: true,
                    cleanupTimeout: 1000,
                });
                const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                    frameParams: {
                        width: '100%',
                        height: '100%',
                    },
                });
                await appEmbed.render();
                const triggerSpy = jest.spyOn(appEmbed, 'trigger').mockResolvedValue(null);
                const removeChildSpy = jest.spyOn(Node.prototype, 'removeChild').mockImplementation(() => (0, test_utils_1.getRootEl)());
                appEmbed.destroy();
                // Should be called immediately when config is enabled
                expect(triggerSpy).toHaveBeenCalledWith(types_1.HostEvent.DestroyEmbed);
                // Wait for the timeout to complete
                await new Promise(resolve => setTimeout(resolve, 1100));
                expect(removeChildSpy).toHaveBeenCalled();
            });
            it('should handle Promise.race with successful cleanup completion', async () => {
                embedConfig.setEmbedConfig({
                    ...originalEmbedConfig,
                    waitForCleanupOnDestroy: true,
                    cleanupTimeout: 2000,
                });
                const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                    frameParams: {
                        width: '100%',
                        height: '100%',
                    },
                });
                await appEmbed.render();
                // Mock trigger to resolve quickly (before timeout)
                const triggerSpy = jest.spyOn(appEmbed, 'trigger').mockImplementation(() => new Promise(resolve => setTimeout(() => resolve(null), 100)));
                const removeChildSpy = jest.spyOn(Node.prototype, 'removeChild').mockImplementation(() => (0, test_utils_1.getRootEl)());
                appEmbed.destroy();
                // Wait for the trigger to complete
                await new Promise(resolve => setTimeout(resolve, 200));
                expect(triggerSpy).toHaveBeenCalledWith(types_1.HostEvent.DestroyEmbed);
                expect(removeChildSpy).toHaveBeenCalled();
            });
            it('should handle Promise.race with timeout when cleanup takes too long', async () => {
                embedConfig.setEmbedConfig({
                    ...originalEmbedConfig,
                    waitForCleanupOnDestroy: true,
                    cleanupTimeout: 100,
                });
                const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
                    frameParams: {
                        width: '100%',
                        height: '100%',
                    },
                });
                await appEmbed.render();
                // Mock trigger to take longer than timeout
                const triggerSpy = jest.spyOn(appEmbed, 'trigger').mockImplementation(() => new Promise(resolve => setTimeout(() => resolve(null), 500)));
                const removeChildSpy = jest.spyOn(Node.prototype, 'removeChild').mockImplementation(() => (0, test_utils_1.getRootEl)());
                appEmbed.destroy();
                // Wait for the timeout to complete
                await new Promise(resolve => setTimeout(resolve, 200));
                expect(triggerSpy).toHaveBeenCalledWith(types_1.HostEvent.DestroyEmbed);
                expect(removeChildSpy).toHaveBeenCalled();
            });
        });
    });
    describe('handleApiInterceptEvent', () => {
        beforeEach(() => {
            document.body.innerHTML = (0, test_utils_1.getDocumentBody)();
            (0, index_1.init)({
                thoughtSpotHost: 'tshost',
                authType: index_1.AuthType.None,
            });
            jest.clearAllMocks();
            mockHandleInterceptEvent.mockClear();
        });
        test('should call handleInterceptEvent with correct parameters', async () => {
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            await searchEmbed.render();
            const mockEventData = {
                type: index_1.EmbedEvent.ApiIntercept,
                data: JSON.stringify({
                    input: '/prism/?op=GetChartWithData',
                    init: {
                        method: 'POST',
                        body: JSON.stringify({
                            variables: {
                                session: { sessionId: 'session-123' },
                                contextBookId: 'viz-456'
                            }
                        })
                    }
                })
            };
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEventData, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(mockHandleInterceptEvent).toHaveBeenCalledTimes(1);
                const call = mockHandleInterceptEvent.mock.calls[0][0];
                expect(call.eventData).toEqual(mockEventData);
                expect(call.executeEvent).toBeInstanceOf(Function);
                expect(call.getUnsavedAnswerTml).toBeInstanceOf(Function);
                expect(call.viewConfig).toMatchObject(defaultViewConfig);
            });
        });
        test('should execute callbacks through executeEvent function', async () => {
            let capturedExecuteEvent;
            mockHandleInterceptEvent.mockImplementation(async (params) => {
                capturedExecuteEvent = params.executeEvent;
            });
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            const mockCallback = jest.fn();
            searchEmbed.on(index_1.EmbedEvent.CustomAction, mockCallback);
            await searchEmbed.render();
            const mockEventData = {
                type: index_1.EmbedEvent.ApiIntercept,
                data: JSON.stringify({
                    input: '/prism/?op=GetChartWithData',
                    init: {}
                })
            };
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEventData, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(capturedExecuteEvent).toBeDefined();
                // Simulate executeEvent being called by handleInterceptEvent
                const testData = { test: 'data' };
                capturedExecuteEvent(index_1.EmbedEvent.CustomAction, testData);
                // executeEvent passes data as first param to callback
                expect(mockCallback).toHaveBeenCalled();
                expect(mockCallback.mock.calls[0][0]).toEqual(testData);
            });
        });
        test('should call triggerUIPassThrough through getUnsavedAnswerTml function', async () => {
            let capturedGetUnsavedAnswerTml;
            mockHandleInterceptEvent.mockImplementation(async (params) => {
                capturedGetUnsavedAnswerTml = params.getUnsavedAnswerTml;
            });
            const mockTmlResponse = { tml: 'test-tml-content' };
            mockProcessTrigger.mockResolvedValue([{ value: mockTmlResponse }]);
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            await searchEmbed.render();
            const mockEventData = {
                type: index_1.EmbedEvent.ApiIntercept,
                data: JSON.stringify({
                    input: '/prism/?op=GetChartWithData',
                    init: {}
                })
            };
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEventData, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(async () => {
                expect(capturedGetUnsavedAnswerTml).toBeDefined();
                // Clear previous calls
                mockProcessTrigger.mockClear();
                // Simulate getUnsavedAnswerTml being called by
                // handleInterceptEvent
                const result = await capturedGetUnsavedAnswerTml({
                    sessionId: 'session-123',
                    vizId: 'viz-456'
                });
                expect(mockProcessTrigger).toHaveBeenCalled();
                const callArgs = mockProcessTrigger.mock.calls[0];
                // Verify UIPassthrough event is triggered with the right params
                expect(callArgs[1]).toBe('UiPassthrough');
                expect(callArgs[3]).toMatchObject({
                    type: 'getUnsavedAnswerTML',
                    parameters: {
                        sessionId: 'session-123',
                        vizId: 'viz-456'
                    }
                });
                expect(result).toEqual(mockTmlResponse);
            });
        });
        test('should pass viewConfig to handleInterceptEvent', async () => {
            const customViewConfig = {
                ...defaultViewConfig,
                interceptUrls: ['/api/test'],
                interceptTimeout: 5000,
            };
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), customViewConfig);
            await searchEmbed.render();
            const mockEventData = {
                type: index_1.EmbedEvent.ApiIntercept,
                data: JSON.stringify({
                    input: '/api/test',
                    init: {}
                })
            };
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEventData, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                const call = mockHandleInterceptEvent.mock.calls[0][0];
                expect(call.viewConfig).toMatchObject({
                    interceptUrls: ['/api/test'],
                    interceptTimeout: 5000,
                });
            });
        });
        test('should handle ApiIntercept event with eventPort', async () => {
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            await searchEmbed.render();
            const mockEventData = {
                type: index_1.EmbedEvent.ApiIntercept,
                data: JSON.stringify({
                    input: '/prism/?op=GetChartWithData',
                    init: {}
                })
            };
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEventData, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(mockHandleInterceptEvent).toHaveBeenCalled();
                // Verify the executeEvent function uses the port
                const executeEventFn = mockHandleInterceptEvent.mock.calls[0][0].executeEvent;
                expect(executeEventFn).toBeDefined();
            });
        });
        test('should not process non-ApiIntercept events through handleApiInterceptEvent', async () => {
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            await searchEmbed.render();
            const mockEventData = {
                type: index_1.EmbedEvent.Save,
                data: { answerId: '123' },
            };
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEventData, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(mockHandleInterceptEvent).not.toHaveBeenCalled();
            });
        });
        test('should handle multiple ApiIntercept events', async () => {
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            await searchEmbed.render();
            const mockEventData1 = {
                type: index_1.EmbedEvent.ApiIntercept,
                data: JSON.stringify({
                    input: '/prism/?op=GetChartWithData',
                    init: {}
                })
            };
            const mockEventData2 = {
                type: index_1.EmbedEvent.ApiIntercept,
                data: JSON.stringify({
                    input: '/prism/?op=LoadContextBook',
                    init: {}
                })
            };
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEventData1, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                (0, test_utils_1.postMessageToParent)((0, test_utils_1.getIFrameEl)().contentWindow, mockEventData2, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(mockHandleInterceptEvent).toHaveBeenCalledTimes(2);
            });
        });
        test('should pass eventPort to executeCallbacks', async () => {
            let capturedExecuteEvent;
            mockHandleInterceptEvent.mockImplementation(async (params) => {
                capturedExecuteEvent = params.executeEvent;
            });
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            const mockCallback = jest.fn();
            searchEmbed.on(index_1.EmbedEvent.ApiIntercept, mockCallback);
            await searchEmbed.render();
            const mockEventData = {
                type: index_1.EmbedEvent.ApiIntercept,
                data: JSON.stringify({
                    input: '/prism/?op=GetChartWithData',
                    init: {}
                })
            };
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEventData, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(capturedExecuteEvent).toBeDefined();
                // Call executeEvent with a response
                const responseData = { execute: true };
                capturedExecuteEvent(index_1.EmbedEvent.ApiIntercept, responseData);
                // Verify the callback was invoked with the data
                expect(mockCallback).toHaveBeenCalled();
                expect(mockCallback.mock.calls[0][0]).toEqual(responseData);
            });
        });
        test('should handle getUnsavedAnswerTml with empty response', async () => {
            let capturedGetUnsavedAnswerTml;
            mockHandleInterceptEvent.mockImplementation(async (params) => {
                capturedGetUnsavedAnswerTml = params.getUnsavedAnswerTml;
            });
            mockProcessTrigger.mockResolvedValue([]);
            const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
            await searchEmbed.render();
            const mockEventData = {
                type: index_1.EmbedEvent.ApiIntercept,
                data: JSON.stringify({
                    input: '/prism/?op=GetChartWithData',
                    init: {}
                })
            };
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEventData, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(async () => {
                expect(capturedGetUnsavedAnswerTml).toBeDefined();
                const result = await capturedGetUnsavedAnswerTml({
                    sessionId: 'session-123',
                    vizId: 'viz-456'
                });
                expect(result).toBeUndefined();
            });
        });
        test('should work with LiveboardEmbed', async () => {
            const liveboardEmbed = new index_1.LiveboardEmbed((0, test_utils_1.getRootEl)(), {
                ...defaultViewConfig,
                liveboardId: 'test-liveboard-id',
            });
            await liveboardEmbed.render();
            const mockEventData = {
                type: index_1.EmbedEvent.ApiIntercept,
                data: JSON.stringify({
                    input: '/prism/?op=LoadContextBook',
                    init: {}
                })
            };
            const mockPort = {
                postMessage: jest.fn(),
            };
            await (0, test_utils_1.executeAfterWait)(() => {
                const iframe = (0, test_utils_1.getIFrameEl)();
                (0, test_utils_1.postMessageToParent)(iframe.contentWindow, mockEventData, mockPort);
            });
            await (0, test_utils_1.executeAfterWait)(() => {
                expect(mockHandleInterceptEvent).toHaveBeenCalledTimes(1);
                expect(mockHandleInterceptEvent).toHaveBeenCalledWith(expect.objectContaining({
                    eventData: mockEventData,
                }));
            });
        });
    });
});
describe('Additional Coverage Tests', () => {
    beforeAll(() => {
        (0, index_1.init)({
            thoughtSpotHost: 'tshost',
            authType: index_1.AuthType.None,
        });
    });
    test('should handle getAuthTokenForCookielessInit with non-cookieless auth', async () => {
        const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
        const token = await searchEmbed['getAuthTokenForCookielessInit']();
        expect(token).toBe('');
    });
    test('should call setIFrameHeight', async () => {
        const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
        await searchEmbed.render();
        await (0, test_utils_1.executeAfterWait)(() => {
            searchEmbed['setIFrameHeight'](500);
            expect((0, test_utils_1.getIFrameEl)().style.height).toBe('500px');
        });
    });
    test('should test getIframeCenter calculation', async () => {
        const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
        await searchEmbed.render();
        await (0, test_utils_1.executeAfterWait)(() => {
            const center = searchEmbed['getIframeCenter']();
            expect(center).toHaveProperty('iframeCenter');
            expect(center).toHaveProperty('iframeHeight');
            expect(center).toHaveProperty('viewPortHeight');
        });
    });
    test('should handle preRender with replaceExistingPreRender=true', async () => {
        (0, test_utils_1.createRootEleForEmbed)();
        const embed1 = new index_1.LiveboardEmbed('#tsEmbedDiv', {
            preRenderId: 'test-replace',
            liveboardId: 'lb1',
        });
        await embed1.preRender();
        const embed2 = new index_1.LiveboardEmbed('#tsEmbedDiv', {
            preRenderId: 'test-replace',
            liveboardId: 'lb2',
        });
        await embed2.preRender(false, true);
        expect(document.getElementById('tsEmbed-pre-render-wrapper-test-replace')).toBeTruthy();
    });
    test('should test getIframeSrc base implementation', () => {
        const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
        expect(searchEmbed.getIframeSrc()).toBe('');
    });
    test('should handle createEmbedEventResponder with OnBeforeGetVizDataIntercept', async () => {
        const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
        const mockPort = { postMessage: jest.fn() };
        const responder = searchEmbed['createEmbedEventResponder'](mockPort, index_1.EmbedEvent.OnBeforeGetVizDataIntercept);
        responder({ data: 'test' });
        expect(mockPort.postMessage).toHaveBeenCalled();
    });
    test('should clean up message event listeners', async () => {
        const removeEventListenerSpy = jest.spyOn(window, 'removeEventListener');
        const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
        await searchEmbed.render();
        searchEmbed['unsubscribeToMessageEvents']();
        expect(removeEventListenerSpy).toHaveBeenCalledWith('message', expect.any(Function));
    });
});
describe('Trigger method edge cases', () => {
    beforeAll(() => {
        (0, index_1.init)({
            thoughtSpotHost: 'tshost',
            authType: index_1.AuthType.None,
        });
    });
    beforeEach(() => {
        document.body.innerHTML = (0, test_utils_1.getDocumentBody)();
    });
    test('should handle error when trigger is called with undefined messageType', async () => {
        const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
        jest.spyOn(logger_1.logger, 'error');
        await searchEmbed.render();
        await (0, test_utils_1.executeAfterWait)(async () => {
            const result = await searchEmbed.trigger(undefined);
            expect(result).toBeNull();
            expect(logger_1.logger.error).toHaveBeenCalledWith(expect.objectContaining({
                errorType: types_1.ErrorDetailsTypes.VALIDATION_ERROR,
                code: types_1.EmbedErrorCodes.HOST_EVENT_TYPE_UNDEFINED,
            }));
        });
    });
    test('should return null when trigger is called before iframe is ready', async () => {
        jest.spyOn(baseInstance, 'getAuthPromise').mockRejectedValueOnce(new Error('Auth failed'));
        const searchEmbed = new index_1.SearchEmbed((0, test_utils_1.getRootEl)(), defaultViewConfig);
        jest.spyOn(logger_1.logger, 'debug');
        await searchEmbed.render();
        await (0, test_utils_1.executeAfterWait)(async () => {
            const result = await searchEmbed.trigger(types_1.HostEvent.Reload);
            expect(result).toBeNull();
        });
    });
});
describe('PreRender replaceExistingPreRender scenarios', () => {
    beforeAll(() => {
        (0, index_1.init)({
            thoughtSpotHost: 'tshost',
            authType: index_1.AuthType.None,
        });
    });
    afterEach(() => {
        const rootEle = document.getElementById('myRoot');
        rootEle === null || rootEle === void 0 ? void 0 : rootEle.remove();
    });
    test('should skip re-rendering when preRender already exists and replaceExistingPreRender is false', async () => {
        (0, test_utils_1.createRootEleForEmbed)();
        const embed1 = new index_1.LiveboardEmbed('#tsEmbedDiv', {
            preRenderId: 'no-replace-test',
            liveboardId: 'lb1',
        });
        await embed1.preRender();
        await (0, test_utils_1.waitFor)(() => !!(0, test_utils_1.getIFrameEl)());
        const embed2 = new index_1.LiveboardEmbed('#tsEmbedDiv', {
            preRenderId: 'no-replace-test',
            liveboardId: 'lb2',
        });
        const result = await embed2.preRender(false, false);
        expect(result).toBe(embed2);
        // The original iframe should still have lb1
        const iframe = (0, test_utils_1.getIFrameEl)();
        expect(iframe.src).toContain('lb1');
    });
});
describe('Destroy error handling', () => {
    beforeAll(() => {
        (0, index_1.init)({
            thoughtSpotHost: 'tshost',
            authType: index_1.AuthType.None,
        });
    });
    beforeEach(() => {
        document.body.innerHTML = (0, test_utils_1.getDocumentBody)();
    });
    test('should handle error gracefully when destroy fails', async () => {
        const appEmbed = new index_1.AppEmbed((0, test_utils_1.getRootEl)(), {
            frameParams: { width: '100%', height: '100%' },
        });
        await appEmbed.render();
        const logSpy = jest.spyOn(logger_1.logger, 'log').mockImplementation(() => { });
        jest.spyOn(Node.prototype, 'removeChild').mockImplementationOnce(() => {
            throw new Error('Remove failed');
        });
        expect(() => {
            appEmbed.destroy();
        }).not.toThrow();
        expect(logSpy).toHaveBeenCalledWith('Error destroying TS Embed', expect.any(Error));
        logSpy.mockReset();
    });
});
describe('Fullscreen change handler behavior', () => {
    beforeAll(() => {
        (0, index_1.init)({
            thoughtSpotHost: 'tshost',
            authType: index_1.AuthType.None,
            disableFullscreenPresentation: false,
        });
    });
    beforeEach(() => {
        document.body.innerHTML = (0, test_utils_1.getDocumentBody)();
    });
    test('should trigger ExitPresentMode when exiting fullscreen', async () => {
        const liveboardEmbed = new index_1.LiveboardEmbed((0, test_utils_1.getRootEl)(), {
            ...defaultViewConfig,
            liveboardId: 'test-lb',
        });
        await liveboardEmbed.render();
        await (0, test_utils_1.executeAfterWait)(() => {
            const iframe = (0, test_utils_1.getIFrameEl)();
            expect(iframe).toBeTruthy();
        });
        mockProcessTrigger.mockResolvedValue({});
        liveboardEmbed['setupFullscreenChangeHandler']();
        Object.defineProperty(document, 'fullscreenElement', {
            value: null,
            writable: true,
            configurable: true,
        });
        const event = new Event('fullscreenchange');
        document.dispatchEvent(event);
        await (0, test_utils_1.executeAfterWait)(() => {
            expect(mockProcessTrigger).toHaveBeenLastCalledWith(expect.any(Object), types_1.HostEvent.ExitPresentMode, expect.any(String), expect.any(Object), undefined);
        });
    });
    test('should not trigger ExitPresentMode when entering fullscreen', async () => {
        const liveboardEmbed = new index_1.LiveboardEmbed((0, test_utils_1.getRootEl)(), {
            ...defaultViewConfig,
            liveboardId: 'test-lb-fullscreen',
        });
        await liveboardEmbed.render();
        await (0, test_utils_1.executeAfterWait)(() => {
            const iframe = (0, test_utils_1.getIFrameEl)();
            expect(iframe).toBeTruthy();
        });
        mockProcessTrigger.mockClear();
        mockProcessTrigger.mockResolvedValue({});
        liveboardEmbed['setupFullscreenChangeHandler']();
        Object.defineProperty(document, 'fullscreenElement', {
            value: (0, test_utils_1.getIFrameEl)(),
            writable: true,
            configurable: true,
        });
        const event = new Event('fullscreenchange');
        document.dispatchEvent(event);
        await (0, test_utils_1.executeAfterWait)(() => {
            expect(mockProcessTrigger).not.toHaveBeenCalledWith(expect.any(Object), types_1.HostEvent.ExitPresentMode, expect.any(String), expect.any(Object));
        });
    });
});
describe('ShowPreRender with UpdateEmbedParams', () => {
    const setupPreRenderTest = async (preRenderId, initialConfig) => {
        (0, test_utils_1.createRootEleForEmbed)();
        (0, test_utils_1.mockMessageChannel)();
        window.ResizeObserver = window.ResizeObserver
            || jest.fn().mockImplementation(() => ({
                disconnect: jest.fn(),
                observe: jest.fn(),
                unobserve: jest.fn(),
            }));
        const embed1 = new index_1.LiveboardEmbed('#tsEmbedDiv', {
            preRenderId,
            ...initialConfig,
        });
        await embed1.preRender();
        await (0, test_utils_1.waitFor)(() => !!(0, test_utils_1.getIFrameEl)());
        embed1.isEmbedContainerLoaded = true;
        mockProcessTrigger.mockClear();
        mockProcessTrigger.mockResolvedValue({});
        return embed1;
    };
    beforeAll(() => {
        (0, index_1.init)({
            thoughtSpotHost: 'tshost',
            authType: index_1.AuthType.None,
        });
    });
    afterEach(() => {
        const rootEle = document.getElementById('myRoot');
        rootEle === null || rootEle === void 0 ? void 0 : rootEle.remove();
    });
    test('should trigger UpdateEmbedParams when showPreRender connects to existing prerendered component', async () => {
        await setupPreRenderTest('update-params-test', { liveboardId: 'original-lb' });
        const embed2 = new index_1.LiveboardEmbed('#tsEmbedDiv', {
            preRenderId: 'update-params-test',
            liveboardId: 'updated-lb',
        });
        embed2.showPreRender();
        await (0, test_utils_1.executeAfterWait)(() => {
            expect(mockProcessTrigger).toHaveBeenLastCalledWith(expect.any(Object), types_1.HostEvent.UpdateEmbedParams, expect.any(String), expect.objectContaining({
                liveboardId: 'updated-lb',
            }), undefined);
        });
    });
    test('should trigger UpdateEmbedParams with runtime filters and visible vizs', async () => {
        await setupPreRenderTest('url-param-test', { liveboardId: 'original-lb' });
        const embed2 = new index_1.LiveboardEmbed('#tsEmbedDiv', {
            preRenderId: 'url-param-test',
            liveboardId: 'original-lb',
            visibleVizs: ['viz-1'],
            runtimeFilters: [
                {
                    columnName: 'Color',
                    operator: types_1.RuntimeFilterOp.IN,
                    values: ['red', 'blue'],
                },
                {
                    columnName: 'Region',
                    operator: types_1.RuntimeFilterOp.EQ,
                    values: ['North'],
                },
            ],
        });
        embed2.showPreRender();
        await (0, test_utils_1.executeAfterWait)(() => {
            expect(mockProcessTrigger).toHaveBeenLastCalledWith(expect.any(Object), types_1.HostEvent.UpdateEmbedParams, expect.any(String), expect.objectContaining({
                liveboardId: 'original-lb',
                visibleVizs: ['viz-1'],
                runtimeFilters: [
                    {
                        columnName: 'Color',
                        operator: types_1.RuntimeFilterOp.IN,
                        values: ['red', 'blue'],
                    },
                    {
                        columnName: 'Region',
                        operator: types_1.RuntimeFilterOp.EQ,
                        values: ['North'],
                    },
                ],
            }), undefined);
        });
    });
    test('should trigger UpdateEmbedParams with updated config', async () => {
        await setupPreRenderTest('preserve-config-test', {
            liveboardId: 'original-lb',
            runtimeFilters: [
                {
                    columnName: 'Color',
                    operator: types_1.RuntimeFilterOp.IN,
                    values: ['red', 'blue'],
                },
            ],
        });
        const embed2 = new index_1.LiveboardEmbed('#tsEmbedDiv', {
            preRenderId: 'preserve-config-test',
            liveboardId: 'original-lb',
            visibleVizs: ['viz-1', 'viz-2'],
            runtimeFilters: [
                {
                    columnName: 'Region',
                    operator: types_1.RuntimeFilterOp.EQ,
                    values: ['North'],
                },
            ],
        });
        embed2.showPreRender();
        await (0, test_utils_1.executeAfterWait)(() => {
            expect(mockProcessTrigger).toHaveBeenLastCalledWith(expect.any(Object), types_1.HostEvent.UpdateEmbedParams, expect.any(String), expect.objectContaining({
                liveboardId: 'original-lb',
                visibleVizs: ['viz-1', 'viz-2'],
                runtimeFilters: [
                    {
                        columnName: 'Region',
                        operator: types_1.RuntimeFilterOp.EQ,
                        values: ['North'],
                    },
                ],
            }), undefined);
        });
    });
    test('should handle error when getUpdateEmbedParamsObject fails during showPreRender', async () => {
        await setupPreRenderTest('error-test', { liveboardId: 'original-lb' });
        const handleErrorSpy = jest.spyOn(index_1.LiveboardEmbed.prototype, 'handleError');
        const embed2 = new index_1.LiveboardEmbed('#tsEmbedDiv', {
            preRenderId: 'error-test',
            liveboardId: 'updated-lb',
        });
        const mockError = new Error('Failed to get params');
        jest.spyOn(embed2, 'getUpdateEmbedParamsObject').mockRejectedValue(mockError);
        embed2.showPreRender();
        await (0, test_utils_1.executeAfterWait)(() => {
            expect(handleErrorSpy).toHaveBeenCalledWith(expect.objectContaining({
                errorType: types_1.ErrorDetailsTypes.API,
                message: 'Failed to get params',
                code: types_1.EmbedErrorCodes.UPDATE_PARAMS_FAILED,
                error: 'Failed to get params',
            }));
            expect(mockProcessTrigger).not.toHaveBeenCalledWith(expect.any(Object), types_1.HostEvent.UpdateEmbedParams, expect.any(String), expect.any(Object));
        });
        handleErrorSpy.mockRestore();
    });
});
//# sourceMappingURL=ts-embed.spec.js.map