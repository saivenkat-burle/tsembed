"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HostEventClient = void 0;
const types_1 = require("../../types");
const processTrigger_1 = require("../../utils/processTrigger");
const embedConfig_1 = require("../embedConfig");
const contracts_1 = require("./contracts");
class HostEventClient {
    constructor(iFrame) {
        this.iFrame = iFrame;
    }
    /**
     * A wrapper over process trigger to
     * @param {HostEvent} message Host event to send
     * @param {any} data Data to send with the host event
     * @returns {Promise<any>} - the response from the process trigger
     */
    async processTrigger(message, data, context) {
        if (!this.iFrame) {
            throw new Error('Iframe element is not set');
        }
        const thoughtspotHost = (0, embedConfig_1.getEmbedConfig)().thoughtSpotHost;
        return (0, processTrigger_1.processTrigger)(this.iFrame, message, thoughtspotHost, data, context);
    }
    async handleHostEventWithParam(apiName, parameters, context) {
        var _a, _b, _c, _d;
        const response = (_b = (_a = (await this.triggerUIPassthroughApi(apiName, parameters, context))) === null || _a === void 0 ? void 0 : _a.filter) === null || _b === void 0 ? void 0 : _b.call(_a, (r) => r.error || r.value)[0];
        if (!response) {
            const error = `No answer found${parameters.vizId ? ` for vizId: ${parameters.vizId}` : ''}.`;
            // eslint-disable-next-line no-throw-literal
            throw { error };
        }
        const errors = response.error
            || ((_c = response.value) === null || _c === void 0 ? void 0 : _c.errors)
            || ((_d = response.value) === null || _d === void 0 ? void 0 : _d.error);
        if (errors) {
            // eslint-disable-next-line no-throw-literal
            throw { error: response.error };
        }
        return { ...response.value };
    }
    async hostEventFallback(hostEvent, data, context) {
        return this.processTrigger(hostEvent, data, context);
    }
    /**
     * Setter for the iframe element used for host events
     * @param {HTMLIFrameElement} iFrame - the iframe element to set
     */
    setIframeElement(iFrame) {
        this.iFrame = iFrame;
    }
    async triggerUIPassthroughApi(apiName, parameters, context) {
        const res = await this.processTrigger(types_1.HostEvent.UIPassthrough, {
            type: apiName,
            parameters,
        }, context);
        return res;
    }
    async handlePinEvent(payload, context) {
        var _a, _b;
        if (!payload || !('newVizName' in payload)) {
            return this.hostEventFallback(types_1.HostEvent.Pin, payload, context);
        }
        const formattedPayload = {
            ...payload,
            pinboardId: (_a = payload.liveboardId) !== null && _a !== void 0 ? _a : payload.pinboardId,
            newPinboardName: (_b = payload.newLiveboardName) !== null && _b !== void 0 ? _b : payload.newPinboardName,
        };
        const data = await this.handleHostEventWithParam(contracts_1.UIPassthroughEvent.PinAnswerToLiveboard, formattedPayload, context);
        return {
            ...data,
            liveboardId: data.pinboardId,
        };
    }
    async handleSaveAnswerEvent(payload, context) {
        var _a, _b, _c, _d;
        if (!payload || !('name' in payload) || !('description' in payload)) {
            // Save is the fallback for SaveAnswer
            return this.hostEventFallback(types_1.HostEvent.Save, payload, context);
        }
        const data = await this.handleHostEventWithParam(contracts_1.UIPassthroughEvent.SaveAnswer, payload, context);
        return {
            ...data,
            answerId: (_d = (_c = (_b = (_a = data === null || data === void 0 ? void 0 : data.saveResponse) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.Answer__save) === null || _c === void 0 ? void 0 : _c.answer) === null || _d === void 0 ? void 0 : _d.id,
        };
    }
    async triggerHostEvent(hostEvent, payload, context) {
        switch (hostEvent) {
            case types_1.HostEvent.Pin:
                return this.handlePinEvent(payload, context);
            case types_1.HostEvent.SaveAnswer:
                return this.handleSaveAnswerEvent(payload, context);
            default:
                return this.hostEventFallback(hostEvent, payload, context);
        }
    }
}
exports.HostEventClient = HostEventClient;
//# sourceMappingURL=host-event-client.js.map