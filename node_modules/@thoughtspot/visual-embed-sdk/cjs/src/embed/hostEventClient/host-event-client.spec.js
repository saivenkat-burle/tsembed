"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const types_1 = require("../../types");
const processTrigger_1 = require("../../utils/processTrigger");
const EmbedConfigService = tslib_1.__importStar(require("../embedConfig"));
const contracts_1 = require("./contracts");
const host_event_client_1 = require("./host-event-client");
jest.mock('../../utils/processTrigger');
const mockProcessTrigger = processTrigger_1.processTrigger;
const createHostEventClient = () => {
    const mockIframe = document.createElement('iframe');
    const client = new host_event_client_1.HostEventClient(mockIframe);
    return { client, mockIframe };
};
describe('HostEventClient', () => {
    const mockThoughtSpotHost = 'http://localhost';
    beforeEach(() => {
        jest.spyOn(EmbedConfigService, 'getEmbedConfig').mockReturnValue({ thoughtSpotHost: mockThoughtSpotHost, authType: types_1.AuthType.None });
    });
    afterEach(() => {
        jest.clearAllMocks();
    });
    describe('executeUIPassthroughApi', () => {
        it('should call processTrigger with correct parameters and return response', async () => {
            const { client, mockIframe } = createHostEventClient();
            const apiName = contracts_1.UIPassthroughEvent.PinAnswerToLiveboard;
            const parameters = {
                newVizName: 'testViz',
            };
            const triggerResponse = Promise.resolve([
                { value: { pinboardId: 'testPinboard', tabId: 'testTab', vizId: 'testVizId' } },
            ]);
            mockProcessTrigger.mockResolvedValue(triggerResponse);
            const result = await client.triggerUIPassthroughApi(apiName, parameters);
            expect(mockProcessTrigger).toHaveBeenCalledWith(mockIframe, types_1.HostEvent.UIPassthrough, mockThoughtSpotHost, {
                type: apiName,
                parameters,
            }, undefined);
            expect(result).toEqual(await triggerResponse);
        });
    });
    describe('handleUIPassthroughForHostEvent', () => {
        it('should return the value from the first valid response', async () => {
            const { client } = createHostEventClient();
            const apiName = contracts_1.UIPassthroughEvent.PinAnswerToLiveboard;
            const parameters = {
                newVizName: 'testViz',
            };
            const triggerResponse = Promise.resolve([
                { value: { pinboardId: 'testPinboard', tabId: 'testTab', vizId: 'testVizId' } },
            ]);
            mockProcessTrigger.mockResolvedValue(triggerResponse);
            const result = await client.handleHostEventWithParam(apiName, parameters);
            expect(result).toEqual({
                pinboardId: 'testPinboard',
                tabId: 'testTab',
                vizId: 'testVizId',
            });
        });
        it('should throw an error if no valid response is found', async () => {
            const { client } = createHostEventClient();
            const apiName = contracts_1.UIPassthroughEvent.PinAnswerToLiveboard;
            const parameters = {
                newVizName: 'testViz',
            };
            const triggerResponse = [];
            mockProcessTrigger.mockResolvedValue(triggerResponse);
            await expect(client.handleHostEventWithParam(apiName, parameters))
                .rejects.toEqual({ error: 'No answer found.' });
        });
        it('should throw an error if no valid response is found for vizId', async () => {
            const { client } = createHostEventClient();
            const apiName = contracts_1.UIPassthroughEvent.PinAnswerToLiveboard;
            const parameters = {
                newVizName: 'testViz',
                vizId: 'testVizId',
            };
            const triggerResponse = [];
            mockProcessTrigger.mockResolvedValue(triggerResponse);
            await expect(client.handleHostEventWithParam(apiName, parameters))
                .rejects.toEqual({ error: 'No answer found for vizId: testVizId.' });
        });
        it('should throw an error if the response contains errors', async () => {
            const { client } = createHostEventClient();
            const apiName = contracts_1.UIPassthroughEvent.PinAnswerToLiveboard;
            const parameters = {
                newVizName: 'testViz',
            };
            const triggerResponse = [
                { error: 'Some error' },
            ];
            mockProcessTrigger.mockResolvedValue(triggerResponse);
            await expect(client.handleHostEventWithParam(apiName, parameters))
                .rejects.toEqual({ error: 'Some error' });
        });
    });
    describe('executeHostEvent', () => {
        it('should call handleUIPassthroughForHostEvent for Pin event', async () => {
            const { client, mockIframe } = createHostEventClient();
            const hostEvent = types_1.HostEvent.Pin;
            const payload = {
                newVizName: 'testViz',
            };
            const mockResponse = {
                value: {
                    pinboardId: 'testPinboard',
                    liveboardId: 'testPinboard',
                    tabId: 'testTab',
                    vizId: 'testVizId',
                },
            };
            mockProcessTrigger.mockResolvedValue([mockResponse]);
            const result = await client.triggerHostEvent(hostEvent, payload);
            expect(mockProcessTrigger).toHaveBeenCalledWith(mockIframe, types_1.HostEvent.UIPassthrough, 'http://localhost', { parameters: payload, type: contracts_1.UIPassthroughEvent.PinAnswerToLiveboard }, undefined);
            expect(result).toEqual(mockResponse.value);
        });
        it('should call handleUIPassthroughForHostEvent for SaveAnswer event', async () => {
            const { client, mockIframe } = createHostEventClient();
            const hostEvent = types_1.HostEvent.SaveAnswer;
            const payload = {
                name: 'Test Answer',
                description: 'Test Description',
                vizId: 'testVizId',
            };
            const mockResponse = [{
                    value: {
                        saveResponse: {
                            data: {
                                Answer__save: {
                                    answer: {
                                        id: 'newAnswer',
                                    },
                                },
                            },
                        },
                    },
                    refId: 'testVizId',
                }];
            mockProcessTrigger.mockResolvedValue(mockResponse);
            const result = await client.triggerHostEvent(hostEvent, payload);
            expect(mockProcessTrigger).toHaveBeenCalledWith(mockIframe, types_1.HostEvent.UIPassthrough, mockThoughtSpotHost, {
                parameters: payload,
                type: 'saveAnswer',
            }, undefined);
            expect(result).toEqual({ answerId: 'newAnswer', ...mockResponse[0].value });
        });
        it('should call hostEventFallback for unmapped events', async () => {
            const { client } = createHostEventClient();
            const hostEvent = 'testEvent';
            const payload = { data: 'testData' };
            const mockResponse = { fallbackResponse: 'data' };
            jest.spyOn(client, 'hostEventFallback').mockResolvedValue(mockResponse);
            const result = await client.triggerHostEvent(hostEvent, payload);
            expect(client.hostEventFallback).toHaveBeenCalledWith(hostEvent, payload, undefined);
            expect(result).toEqual(mockResponse);
        });
        it('should call fallback  for Pin event', async () => {
            const { client, mockIframe } = createHostEventClient();
            const hostEvent = types_1.HostEvent.Pin;
            const payload = {};
            const mockResponse = {
                value: {
                    pinboardId: 'testPinboard',
                    tabId: 'testTab',
                    vizId: 'testVizId',
                },
            };
            mockProcessTrigger.mockResolvedValue([mockResponse]);
            const result = await client.triggerHostEvent(hostEvent, payload);
            expect(mockProcessTrigger).toHaveBeenCalledWith(mockIframe, types_1.HostEvent.Pin, mockThoughtSpotHost, {}, undefined);
            expect(result).toEqual([mockResponse]);
        });
        it('should call fallback for SaveAnswer event', async () => {
            const { client, mockIframe } = createHostEventClient();
            const hostEvent = types_1.HostEvent.SaveAnswer;
            const payload = {};
            const mockResponse = {
                value: {
                    pinboardId: 'testPinboard',
                    tabId: 'testTab',
                    vizId: 'testVizId',
                },
            };
            mockProcessTrigger.mockResolvedValue([mockResponse]);
            const result = await client.triggerHostEvent(hostEvent, payload);
            expect(mockProcessTrigger).toHaveBeenCalledWith(mockIframe, types_1.HostEvent.Save, mockThoughtSpotHost, {}, undefined);
            expect(result).toEqual([mockResponse]);
        });
        it('Pin response support pinboardId as well', async () => {
            const { client, mockIframe } = createHostEventClient();
            const hostEvent = types_1.HostEvent.Pin;
            const payload = {
                newVizDescription: 'Test Description',
                vizId: 'testVizId',
                newVizName: 'Test Answer',
                newLiveboardName: 'testLiveboard',
            };
            const mockResponse = [{
                    value: {
                        pinboardId: 'testLiveboard',
                        liveboardId: 'testPinboard',
                        tabId: 'testTab',
                        vizId: 'testVizId',
                    },
                    refId: 'testVizId',
                }];
            mockProcessTrigger.mockResolvedValue(mockResponse);
            const result = await client.triggerHostEvent(hostEvent, payload);
            expect(result.liveboardId).toBe('testLiveboard');
        });
        it('should request liveboardId as well', async () => {
            const { client, mockIframe } = createHostEventClient();
            const hostEvent = types_1.HostEvent.Pin;
            const payload = {
                liveboardId: 'test',
                newVizName: 'Test Answer',
                newPinboardName: 'testLiveboard1',
                newLiveboardName: 'testLiveboard',
            };
            const mockResponse = [{
                    value: {
                        pinboardId: 'testLiveboard',
                        tabId: 'testTab',
                        vizId: 'testVizId',
                    },
                    refId: 'testVizId',
                }];
            mockProcessTrigger.mockResolvedValue(mockResponse);
            const result = await client.triggerHostEvent(hostEvent, payload);
            expect(result.liveboardId).toBe('testLiveboard');
            expect(mockProcessTrigger).toHaveBeenCalledWith(mockIframe, types_1.HostEvent.UIPassthrough, mockThoughtSpotHost, {
                parameters: { ...payload, pinboardId: 'test', newPinboardName: 'testLiveboard' },
                type: 'addVizToPinboard',
            }, undefined);
            expect(result).toEqual({
                pinboardId: 'testLiveboard',
                tabId: 'testTab',
                vizId: 'testVizId',
                liveboardId: 'testLiveboard',
            });
        });
    });
});
//# sourceMappingURL=host-event-client.spec.js.map