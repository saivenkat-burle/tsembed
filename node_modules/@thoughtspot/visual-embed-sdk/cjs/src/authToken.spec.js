"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const authToken_1 = require("./authToken");
const authTokenModule = tslib_1.__importStar(require("./authToken"));
const authServiceInstance = tslib_1.__importStar(require("./utils/authService/authService"));
const types_1 = require("./types");
const utils_1 = require("./utils");
const logger_1 = require("./utils/logger");
const errors_1 = require("./errors");
describe('AuthToken Unit tests', () => {
    test('getAuthenticationToken: When verification is disabled', async () => {
        jest.spyOn(authServiceInstance, 'verifyTokenService');
        const token = await (0, authToken_1.getAuthenticationToken)({
            getAuthToken: async () => 'abc3',
            disableTokenVerification: true,
        });
        expect(token).toBe('abc3');
        expect(authServiceInstance.verifyTokenService).not.toHaveBeenCalled();
    });
    test('getAuthenticationToken: When verification is enabled', async () => {
        (0, authToken_1.resetCachedAuthToken)();
        jest.clearAllMocks();
        jest.spyOn(authServiceInstance, 'verifyTokenService').mockImplementation(() => Promise.resolve(true));
        const token = await (0, authToken_1.getAuthenticationToken)({
            thoughtSpotHost: 'test',
            getAuthToken: async () => 'abc2',
            disableTokenVerification: false,
        });
        expect(token).toBe('abc2');
        expect(authServiceInstance.verifyTokenService).toHaveBeenCalledWith('test', 'abc2');
    });
    test('validateAuthToken : When token is invalid by type number', async () => {
        jest.spyOn(logger_1.logger, 'error').mockImplementation(() => { });
        const loggerSpy = jest.spyOn(logger_1.logger, 'error');
        const authToken = 123;
        const errorMessage = (0, utils_1.formatTemplate)(errors_1.ERROR_MESSAGE.INVALID_TOKEN_TYPE_ERROR, {
            invalidType: typeof authToken,
        });
        await expect((0, authToken_1.validateAuthToken)({
            thoughtSpotHost: 'test',
        }, authToken)).rejects.toThrow(errorMessage);
        expect(loggerSpy).toHaveBeenCalledWith(errorMessage);
        loggerSpy.mockRestore();
    });
    test('validateAuthToken : When token is invalid by type object', async () => {
        jest.spyOn(logger_1.logger, 'error').mockImplementation(() => { });
        const loggerSpy = jest.spyOn(logger_1.logger, 'error');
        const authToken = {};
        const errorMessage = (0, utils_1.formatTemplate)(errors_1.ERROR_MESSAGE.INVALID_TOKEN_TYPE_ERROR, {
            invalidType: typeof authToken,
        });
        await expect((0, authToken_1.validateAuthToken)({
            thoughtSpotHost: 'test',
        }, authToken)).rejects.toThrow(errorMessage);
        expect(loggerSpy).toHaveBeenCalledWith(errorMessage);
        loggerSpy.mockRestore();
    });
    describe('getAuthenticationToken: cached token skip validation condition', () => {
        beforeEach(() => {
            (0, authToken_1.resetCachedAuthToken)();
            jest.clearAllMocks();
        });
        test('should validate cached token when validation is not skipped', async () => {
            const cachedToken = 'cached-token-123';
            (0, utils_1.storeValueInWindow)('cachedAuthToken', cachedToken);
            const validateAuthTokenSpy = jest.spyOn(authTokenModule, 'validateAuthToken')
                .mockImplementation(() => Promise.resolve(true));
            const getAuthTokenMock = jest.fn().mockResolvedValue('new-token-456');
            const config = {
                thoughtSpotHost: 'test',
                authType: types_1.AuthType.TrustedAuthToken,
                getAuthToken: getAuthTokenMock,
                disableTokenVerification: false,
            };
            const token = await (0, authToken_1.getAuthenticationToken)(config, false);
            expect(token).toBe(cachedToken);
            // Should validate cached token (condition at line 23 is true)
            expect(validateAuthTokenSpy).toHaveBeenCalledWith(config, cachedToken, true);
            expect(getAuthTokenMock).not.toHaveBeenCalled();
            validateAuthTokenSpy.mockReset();
        });
        test('should skip cached token validation when disableTokenVerification is true', async () => {
            const cachedToken = 'cached-token-123';
            (0, utils_1.storeValueInWindow)('cachedAuthToken', cachedToken);
            const validateAuthTokenSpy = jest.spyOn(authTokenModule, 'validateAuthToken')
                .mockImplementation(() => Promise.resolve(true));
            const newToken = 'new-token-456';
            const getAuthTokenMock = jest.fn().mockResolvedValue(newToken);
            const config = {
                thoughtSpotHost: 'test',
                authType: types_1.AuthType.TrustedAuthToken,
                getAuthToken: getAuthTokenMock,
                disableTokenVerification: true,
            };
            const token = await (0, authToken_1.getAuthenticationToken)(config, false);
            expect(token).toBe(newToken);
            // Should not validate cached token (condition at line 23 is false)
            expect(validateAuthTokenSpy).not.toHaveBeenCalledWith(config, cachedToken, true);
            // But should validate new token (though it returns early when disableTokenVerification is true)
            expect(validateAuthTokenSpy).toHaveBeenCalledWith(config, newToken);
            expect(getAuthTokenMock).toHaveBeenCalled();
            validateAuthTokenSpy.mockReset();
        });
        test('should skip cached token validation when skipvalidation is true', async () => {
            const cachedToken = 'cached-token-123';
            (0, utils_1.storeValueInWindow)('cachedAuthToken', cachedToken);
            const validateAuthTokenSpy = jest.spyOn(authTokenModule, 'validateAuthToken')
                .mockImplementation(() => Promise.resolve(true));
            const newToken = 'new-token-456';
            const getAuthTokenMock = jest.fn().mockResolvedValue(newToken);
            const config = {
                thoughtSpotHost: 'test',
                authType: types_1.AuthType.TrustedAuthToken,
                getAuthToken: getAuthTokenMock,
                disableTokenVerification: false,
            };
            const token = await (0, authToken_1.getAuthenticationToken)(config, true);
            expect(token).toBe(newToken);
            // Should not validate cached token (condition at line 23 is false)
            expect(validateAuthTokenSpy).not.toHaveBeenCalledWith(config, cachedToken, true);
            // But should validate new token
            expect(validateAuthTokenSpy).toHaveBeenCalledWith(config, newToken);
            expect(getAuthTokenMock).toHaveBeenCalled();
            validateAuthTokenSpy.mockReset();
        });
    });
});
//# sourceMappingURL=authToken.spec.js.map